<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Artillery Golf Prototype</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f14;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #hud {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(8, 12, 18, 0.7);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e6edf5;
      font-size: 13px;
      line-height: 1.4;
      display: grid;
      gap: 10px;
      min-width: 220px;
      backdrop-filter: blur(6px);
    }
    .hud-row {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 8px;
    }
    .hud-label {
      font-weight: 600;
      color: #ffffff;
    }
    .hud-value {
      font-variant-numeric: tabular-nums;
      text-align: center;
      padding: 2px 8px;
      border-radius: 6px;
      background: rgba(255,255,255,0.08);
    }
    .hud-btn {
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #ffffff;
      cursor: pointer;
    }
    .hud-btn:active {
      transform: translateY(1px);
    }
    canvas { display: block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div class="hud-row">
      <div class="hud-label">Gun rotation</div>
      <div id="gunRotationValue" class="hud-value">0째</div>
      <button id="gunRotationDown" class="hud-btn" type="button">&lt;</button>
      <button id="gunRotationUp" class="hud-btn" type="button">&gt;</button>
    </div>
    <div class="hud-row">
      <div class="hud-label">Gun elevation</div>
      <div id="gunElevationValue" class="hud-value">0째</div>
      <button id="gunElevationUp" class="hud-btn" type="button">^</button>
      <button id="gunElevationDown" class="hud-btn" type="button">\/</button>
    </div>
    <div class="hud-row">
      <div class="hud-label">Scale position</div>
      <div id="scalePositionValue" class="hud-value">x=0.00 y=0.00 z=0.00</div>
      <div></div>
      <div></div>
    </div>
    <div class="hud-row">
      <div class="hud-label">Cannon position</div>
      <div id="cannonPositionValue" class="hud-value">x=0.00 y=0.00 z=0.00</div>
      <div></div>
      <div></div>
    </div>
  </div>
  <script type="module">
    import * as THREE from 'three';

    const CONFIG = {
      camera: {
        fov: 65,
        near: 0.1,
        far: 120,
        position: { x: 0, y: 1.65, z: 8 },
        lookAt: { x: 0, y: 0, z: 0 },
        yawOffsetDeg: 180
      },
      ground: {
        size: 80,
        tileSize: 1,
        colorA: '#101724',
        colorB: '#0b111b'
      },
      scaleCylinder: {
        radius: 0.18,
        height: 1.8,
        position: { x: -3.2, y: 0.9, z: 0.6 }
      },
      cannon: {
        position: { x: 3.2, y: 0, z: 0 },
        scale: 1.5,
        rotationYDeg: 180
      },
      axis: {
        origin: { x: 0, y: 0.6, z: 0 },
        size: 0.6,
        labelOffset: 0.75,
        labelSize: 0.18
      },
      checkerTexture: {
        textureSize: 256
      },
      controls: {
        lookSensitivity: 0.0035,
        maxPitchDeg: 85,
        moveSpeed: 3.0
      }
    };

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 8, 45);

    const camera = new THREE.PerspectiveCamera(
      CONFIG.camera.fov,
      window.innerWidth / window.innerHeight,
      CONFIG.camera.near,
      CONFIG.camera.far
    );
    camera.position.set(
      CONFIG.camera.position.x,
      CONFIG.camera.position.y,
      CONFIG.camera.position.z
    );

    scene.add(new THREE.AmbientLight(0xffffff, 0.75));
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.1);
    keyLight.position.set(6, 8, 4);
    scene.add(keyLight);

    function createCheckerTexture() {
      const size = CONFIG.checkerTexture.textureSize;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const square = size / 2;
      ctx.fillStyle = CONFIG.ground.colorA;
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = CONFIG.ground.colorB;
      ctx.fillRect(0, 0, square, square);
      ctx.fillRect(square, square, square, square);

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      const repeat = CONFIG.ground.size / CONFIG.ground.tileSize;
      texture.repeat.set(repeat, repeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return texture;
    }

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(CONFIG.ground.size, CONFIG.ground.size),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.95,
        metalness: 0.05,
        map: createCheckerTexture()
      })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    const scaleCylinder = new THREE.Mesh(
      new THREE.CylinderGeometry(
        CONFIG.scaleCylinder.radius,
        CONFIG.scaleCylinder.radius,
        CONFIG.scaleCylinder.height,
        32
      ),
      new THREE.MeshStandardMaterial({ color: 0x4ea3ff, roughness: 0.4, metalness: 0.2 })
    );
    scaleCylinder.position.set(
      CONFIG.scaleCylinder.position.x,
      CONFIG.scaleCylinder.position.y,
      CONFIG.scaleCylinder.position.z
    );
    scene.add(scaleCylinder);

    const cannon = new THREE.Group();
    cannon.position.set(
      CONFIG.cannon.position.x,
      CONFIG.cannon.position.y,
      CONFIG.cannon.position.z
    );
    cannon.rotation.y = THREE.MathUtils.degToRad(CONFIG.cannon.rotationYDeg);
    cannon.scale.set(CONFIG.cannon.scale, CONFIG.cannon.scale, CONFIG.cannon.scale);
    scene.add(cannon);

    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x2d2d2d, roughness: 0.7, metalness: 0.1 });
    const wheelGeometry = new THREE.CylinderGeometry(0.55, 0.55, 0.18, 32);
    const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
    leftWheel.rotation.z = Math.PI / 2;
    leftWheel.position.set(-0.75, 0.55, 0.25);
    const rightWheel = leftWheel.clone();
    rightWheel.position.x = 0.75;

    cannon.add(leftWheel, rightWheel);

    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x55606b, roughness: 0.55, metalness: 0.25 });
    const base = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 1.0), baseMaterial);
    base.position.set(0, 0.4, 0.1);
    cannon.add(base);

    const carriage = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.5, 0.9), baseMaterial);
    carriage.position.set(0, 0.95, 0.05);
    cannon.add(carriage);

    const barrelGroup = new THREE.Group();
    barrelGroup.position.set(0, 1.5, 0.0);
    barrelGroup.rotation.x = -THREE.MathUtils.degToRad(40);

    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x7d8792, roughness: 0.35, metalness: 0.6 });
    const mainBarrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.18, 0.22, 2.4, 32),
      barrelMaterial
    );
    mainBarrel.rotation.x = Math.PI / 2;
    mainBarrel.position.set(0, 0, -0.6);

    const innerBarrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.12, 1.6, 32),
      barrelMaterial
    );
    innerBarrel.rotation.x = Math.PI / 2;
    innerBarrel.position.set(0, 0, 0.5);

    barrelGroup.add(mainBarrel, innerBarrel);
    cannon.add(barrelGroup);

    const lookAtTarget = new THREE.Vector3(
      CONFIG.camera.lookAt.x,
      CONFIG.camera.lookAt.y,
      CONFIG.camera.lookAt.z
    );
    camera.lookAt(lookAtTarget);

    const axisOrigin = new THREE.Vector3(
      CONFIG.axis.origin.x,
      CONFIG.axis.origin.y,
      CONFIG.axis.origin.z
    );
    const axesHelper = new THREE.AxesHelper(CONFIG.axis.size);
    axesHelper.position.copy(axisOrigin);
    scene.add(axesHelper);

    function makeAxisLabel(text, color) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.font = 'bold 72px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = color;
      ctx.fillText(text, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      return new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.axis.labelSize, CONFIG.axis.labelSize), mat);
    }

    const axisLabels = {
      x: makeAxisLabel('X', '#ff5b5b'),
      y: makeAxisLabel('Y', '#53ff74'),
      z: makeAxisLabel('Z', '#4ea3ff')
    };
    axisLabels.x.position.copy(axisOrigin).add(new THREE.Vector3(CONFIG.axis.labelOffset, 0, 0));
    axisLabels.y.position.copy(axisOrigin).add(new THREE.Vector3(0, CONFIG.axis.labelOffset, 0));
    axisLabels.z.position.copy(axisOrigin).add(new THREE.Vector3(0, 0, CONFIG.axis.labelOffset));
    scene.add(axisLabels.x, axisLabels.y, axisLabels.z);

    const ui = {
      gunRotationValue: document.getElementById('gunRotationValue'),
      gunElevationValue: document.getElementById('gunElevationValue'),
      scalePositionValue: document.getElementById('scalePositionValue'),
      cannonPositionValue: document.getElementById('cannonPositionValue'),
      gunRotationDown: document.getElementById('gunRotationDown'),
      gunRotationUp: document.getElementById('gunRotationUp'),
      gunElevationUp: document.getElementById('gunElevationUp'),
      gunElevationDown: document.getElementById('gunElevationDown')
    };

    let gunRotationDeg = THREE.MathUtils.radToDeg(cannon.rotation.y);
    let gunElevationDeg = -THREE.MathUtils.radToDeg(barrelGroup.rotation.x);

    function applyGunRotation() {
      cannon.rotation.y = THREE.MathUtils.degToRad(gunRotationDeg);
      ui.gunRotationValue.textContent = `${gunRotationDeg.toFixed(0)}째`;
    }

    function applyGunElevation() {
      barrelGroup.rotation.x = -THREE.MathUtils.degToRad(gunElevationDeg);
      ui.gunElevationValue.textContent = `${gunElevationDeg.toFixed(0)}째`;
    }

    function updatePositionReadouts() {
      const scalePos = scaleCylinder.position;
      const cannonPos = cannon.position;
      ui.scalePositionValue.textContent = `x=${scalePos.x.toFixed(2)} y=${scalePos.y.toFixed(2)} z=${scalePos.z.toFixed(2)}`;
      ui.cannonPositionValue.textContent = `x=${cannonPos.x.toFixed(2)} y=${cannonPos.y.toFixed(2)} z=${cannonPos.z.toFixed(2)}`;
    }

    ui.gunRotationDown.addEventListener('click', () => {
      gunRotationDeg -= 5;
      applyGunRotation();
    });
    ui.gunRotationUp.addEventListener('click', () => {
      gunRotationDeg += 5;
      applyGunRotation();
    });
    ui.gunElevationUp.addEventListener('click', () => {
      gunElevationDeg += 5;
      applyGunElevation();
    });
    ui.gunElevationDown.addEventListener('click', () => {
      gunElevationDeg -= 5;
      applyGunElevation();
    });

    applyGunRotation();
    applyGunElevation();
    updatePositionReadouts();

    camera.rotation.order = 'YXZ';
    const lookDirection = new THREE.Vector3()
      .subVectors(lookAtTarget, camera.position)
      .normalize();
    let yaw = Math.atan2(lookDirection.x, lookDirection.z);
    let pitch = Math.asin(THREE.MathUtils.clamp(lookDirection.y, -1, 1));
    yaw += THREE.MathUtils.degToRad(CONFIG.camera.yawOffsetDeg);
    const lookSensitivity = CONFIG.controls.lookSensitivity;
    const maxPitch = THREE.MathUtils.degToRad(CONFIG.controls.maxPitchDeg);
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function applyCameraOrientation() {
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      if (event.target.closest('#hud')) return;
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isDragging) return;
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      yaw -= dx * lookSensitivity;
      pitch -= dy * lookSensitivity;
      pitch = THREE.MathUtils.clamp(pitch, -maxPitch, maxPitch);
      applyCameraOrientation();
    });

    const pressedKeys = new Set();
    window.addEventListener('keydown', (event) => {
      pressedKeys.add(event.code);
    });
    window.addEventListener('keyup', (event) => {
      pressedKeys.delete(event.code);
    });

    const moveSpeed = CONFIG.controls.moveSpeed;
    const moveVector = new THREE.Vector3();

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      moveVector.set(0, 0, 0);
      if (pressedKeys.has('KeyW')) moveVector.z -= 1;
      if (pressedKeys.has('KeyS')) moveVector.z += 1;
      if (pressedKeys.has('KeyA')) moveVector.x -= 1;
      if (pressedKeys.has('KeyD')) moveVector.x += 1;
      if (moveVector.lengthSq() > 0) {
        moveVector.normalize();
        camera.position.x += moveVector.x * moveSpeed * dt;
        camera.position.z += moveVector.z * moveSpeed * dt;
      }
      axisLabels.x.lookAt(camera.position);
      axisLabels.y.lookAt(camera.position);
      axisLabels.z.lookAt(camera.position);
      renderer.render(scene, camera);
    }
    applyCameraOrientation();
    const clock = new THREE.Clock();
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
