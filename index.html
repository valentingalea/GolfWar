<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Scene</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f14;
      overflow: hidden;
    }
    canvas { display: block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <script type="module">
    import * as THREE from 'three';

    const CONFIG = {
      camera: {
        fov: 65,
        near: 0.1,
        far: 500,
        position: { x: 0, y: 1.65, z: 5 },
        lookAt: { x: 0, y: 0, z: 0 }
      },
      ground: {
        size: 1000,
        tileSize: 1,
        colorA: '#3a3a3a',
        colorB: '#2a2a2a'
      },
      axis: {
        origin: { x: 0, y: 0.5, z: 0 },
        size: 2,
        labelOffset: 2.3,
        labelSize: 0.3
      },
      controls: {
        lookSensitivity: 0.003,
        maxPitchDeg: 89,
        moveSpeed: 5.0
      }
    };

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      CONFIG.camera.fov,
      window.innerWidth / window.innerHeight,
      CONFIG.camera.near,
      CONFIG.camera.far
    );
    camera.position.set(
      CONFIG.camera.position.x,
      CONFIG.camera.position.y,
      CONFIG.camera.position.z
    );
    camera.rotation.order = 'YXZ';

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Create checkerboard texture
    function createCheckerTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const square = size / 2;
      ctx.fillStyle = CONFIG.ground.colorA;
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = CONFIG.ground.colorB;
      ctx.fillRect(0, 0, square, square);
      ctx.fillRect(square, square, square, square);

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      const repeat = CONFIG.ground.size / CONFIG.ground.tileSize;
      texture.repeat.set(repeat, repeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return texture;
    }

    // Ground plane
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(CONFIG.ground.size, CONFIG.ground.size),
      new THREE.MeshStandardMaterial({
        map: createCheckerTexture(),
        roughness: 0.9,
        metalness: 0.1
      })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Axis helper at origin
    const axisOrigin = new THREE.Vector3(
      CONFIG.axis.origin.x,
      CONFIG.axis.origin.y,
      CONFIG.axis.origin.z
    );

    // Create custom axis lines
    function createAxisLine(direction, color, length) {
      const material = new THREE.LineBasicMaterial({ color });
      const points = [
        axisOrigin.clone(),
        axisOrigin.clone().add(direction.clone().multiplyScalar(length))
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      return new THREE.Line(geometry, material);
    }

    const xAxis = createAxisLine(new THREE.Vector3(1, 0, 0), 0xff4444, CONFIG.axis.size);
    const yAxis = createAxisLine(new THREE.Vector3(0, 1, 0), 0x44ff44, CONFIG.axis.size);
    const zAxis = createAxisLine(new THREE.Vector3(0, 0, 1), 0x4444ff, CONFIG.axis.size);
    scene.add(xAxis, yAxis, zAxis);

    // Create axis labels
    function makeAxisLabel(text, color) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.font = 'bold 80px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = color;
      ctx.fillText(text, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(CONFIG.axis.labelSize, CONFIG.axis.labelSize, 1);
      return sprite;
    }

    const labelX = makeAxisLabel('X', '#ff4444');
    const labelY = makeAxisLabel('Y', '#44ff44');
    const labelZ = makeAxisLabel('Z', '#4444ff');

    labelX.position.copy(axisOrigin).add(new THREE.Vector3(CONFIG.axis.labelOffset, 0, 0));
    labelY.position.copy(axisOrigin).add(new THREE.Vector3(0, CONFIG.axis.labelOffset, 0));
    labelZ.position.copy(axisOrigin).add(new THREE.Vector3(0, 0, CONFIG.axis.labelOffset));

    scene.add(labelX, labelY, labelZ);

    // ========== HOWITZER MODEL ==========
    const howitzer = new THREE.Group();
    howitzer.position.set(3, 0, 0);
    howitzer.rotation.y = Math.PI; // Rotate 180 to face camera forward direction
    howitzer.scale.setScalar(1.2); // Scale up 20% for military presence
    scene.add(howitzer);

    // Materials
    const metalDark = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.6, metalness: 0.4 });
    const metalMid = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.5, metalness: 0.5 });
    const metalLight = new THREE.MeshStandardMaterial({ color: 0x6a6a6a, roughness: 0.4, metalness: 0.6 });
    const rubber = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9, metalness: 0.0 });

    // === WHEELS ===
    const wheelRadius = 0.5;
    const wheelWidth = 0.28; // Wider, chunkier wheels
    const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 32);

    // Wheel with hub detail
    function createWheel() {
      const wheelGroup = new THREE.Group();

      // Tire
      const tire = new THREE.Mesh(wheelGeometry, rubber);
      tire.rotation.z = Math.PI / 2;
      wheelGroup.add(tire);

      // Hub
      const hubGeometry = new THREE.CylinderGeometry(0.15, 0.15, wheelWidth + 0.02, 16);
      const hub = new THREE.Mesh(hubGeometry, metalMid);
      hub.rotation.z = Math.PI / 2;
      wheelGroup.add(hub);

      // Spokes
      const spokeGeometry = new THREE.BoxGeometry(0.04, wheelRadius * 1.6, 0.03);
      for (let i = 0; i < 6; i++) {
        const spoke = new THREE.Mesh(spokeGeometry, metalMid);
        spoke.rotation.x = (i / 6) * Math.PI;
        wheelGroup.add(spoke);
      }

      return wheelGroup;
    }

    const leftWheel = createWheel();
    leftWheel.position.set(-0.9, wheelRadius, 0.3);
    howitzer.add(leftWheel);

    const rightWheel = createWheel();
    rightWheel.position.set(0.9, wheelRadius, 0.3);
    howitzer.add(rightWheel);

    // Axle
    const axleGeometry = new THREE.CylinderGeometry(0.06, 0.06, 2.0, 16);
    const axle = new THREE.Mesh(axleGeometry, metalDark);
    axle.rotation.z = Math.PI / 2;
    axle.position.set(0, wheelRadius, 0.3);
    howitzer.add(axle);

    // === TRAILS (legs with spades) ===
    function createTrail(side) {
      const trailGroup = new THREE.Group();

      // Main trail beam
      const beamGeometry = new THREE.BoxGeometry(0.12, 0.15, 2.5);
      const beam = new THREE.Mesh(beamGeometry, metalMid);
      beam.position.set(0, 0.08, -1.25);
      trailGroup.add(beam);

      // Spade (anti-recoil plate that digs into ground)
      const spadeGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.05);
      const spade = new THREE.Mesh(spadeGeometry, metalDark);
      spade.position.set(0, 0.1, -2.5);
      spade.rotation.x = -0.3; // Angled to dig in
      trailGroup.add(spade);

      // Spade spike
      const spikeGeometry = new THREE.ConeGeometry(0.06, 0.2, 8);
      const spike = new THREE.Mesh(spikeGeometry, metalDark);
      spike.position.set(0, -0.05, -2.55);
      spike.rotation.x = Math.PI / 2;
      trailGroup.add(spike);

      trailGroup.position.x = side * 0.5;
      return trailGroup;
    }

    howitzer.add(createTrail(-1)); // Left trail
    howitzer.add(createTrail(1));  // Right trail

    // Trail cross-brace
    const braceGeometry = new THREE.BoxGeometry(1.1, 0.08, 0.08);
    const brace = new THREE.Mesh(braceGeometry, metalMid);
    brace.position.set(0, 0.12, -1.8);
    howitzer.add(brace);

    // === CARRIAGE (main body) ===
    const carriageGeometry = new THREE.BoxGeometry(0.9, 0.35, 0.8);
    const carriage = new THREE.Mesh(carriageGeometry, metalMid);
    carriage.position.set(0, 0.45, 0.1);
    howitzer.add(carriage);

    // Carriage top plate
    const topPlateGeometry = new THREE.BoxGeometry(0.7, 0.08, 0.6);
    const topPlate = new THREE.Mesh(topPlateGeometry, metalLight);
    topPlate.position.set(0, 0.65, 0.1);
    howitzer.add(topPlate);

    // === PIVOT/CRADLE BASE ===
    const pivotBaseGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.2, 24);
    const pivotBase = new THREE.Mesh(pivotBaseGeometry, metalLight);
    pivotBase.position.set(0, 0.75, 0.1);
    howitzer.add(pivotBase);

    // === ELEVATING GROUP (barrel assembly that tilts) ===
    const elevatingGroup = new THREE.Group();
    elevatingGroup.position.set(0, 0.85, 0.1);
    // Set elevation to 40 degrees
    elevatingGroup.rotation.x = -THREE.MathUtils.degToRad(40);
    howitzer.add(elevatingGroup);

    // Cradle (holds the barrel)
    const cradleGeometry = new THREE.BoxGeometry(0.5, 0.25, 0.8);
    const cradle = new THREE.Mesh(cradleGeometry, metalMid);
    cradle.position.set(0, 0, 0.2);
    elevatingGroup.add(cradle);

    // === BARREL ASSEMBLY (piston mechanism) ===
    // Outer cylinder (recoil housing/recuperator)
    const outerBarrelRadius = 0.14;
    const outerBarrelLength = 1.8;
    const outerBarrelGeometry = new THREE.CylinderGeometry(
      outerBarrelRadius, outerBarrelRadius * 1.1, outerBarrelLength, 32
    );
    const outerBarrel = new THREE.Mesh(outerBarrelGeometry, metalMid);
    outerBarrel.rotation.x = Math.PI / 2;
    outerBarrel.position.set(0, 0.05, outerBarrelLength / 2 + 0.3);
    elevatingGroup.add(outerBarrel);

    // Inner cylinder (actual barrel - slides back on recoil)
    const innerBarrelRadius = 0.09;
    const innerBarrelLength = 2.2;
    const innerBarrelGeometry = new THREE.CylinderGeometry(
      innerBarrelRadius, innerBarrelRadius, innerBarrelLength, 32
    );
    const innerBarrel = new THREE.Mesh(innerBarrelGeometry, metalLight);
    innerBarrel.rotation.x = Math.PI / 2;
    innerBarrel.position.set(0, 0.05, innerBarrelLength / 2 + 0.6);
    elevatingGroup.add(innerBarrel);

    // Store base position for recoil animation
    const innerBarrelBaseZ = innerBarrel.position.z;

    // Muzzle brake (at tip of barrel)
    const muzzleBrakeGeometry = new THREE.CylinderGeometry(0.12, 0.11, 0.25, 32);
    const muzzleBrake = new THREE.Mesh(muzzleBrakeGeometry, metalDark);
    muzzleBrake.rotation.x = Math.PI / 2;
    muzzleBrake.position.set(0, 0.05, innerBarrelLength + 0.75);
    elevatingGroup.add(muzzleBrake);

    // Muzzle brake vents
    const ventGeometry = new THREE.BoxGeometry(0.25, 0.04, 0.06);
    for (let i = 0; i < 3; i++) {
      const vent = new THREE.Mesh(ventGeometry, metalDark);
      vent.position.set(0, 0.05, innerBarrelLength + 0.65 + i * 0.08);
      elevatingGroup.add(vent);
    }

    // Breech (back of barrel)
    const breechGeometry = new THREE.CylinderGeometry(0.16, 0.18, 0.35, 32);
    const breech = new THREE.Mesh(breechGeometry, metalDark);
    breech.rotation.x = Math.PI / 2;
    breech.position.set(0, 0.05, 0);
    elevatingGroup.add(breech);

    // Breech block
    const breechBlockGeometry = new THREE.BoxGeometry(0.22, 0.22, 0.12);
    const breechBlock = new THREE.Mesh(breechBlockGeometry, metalDark);
    breechBlock.position.set(0, 0.05, -0.15);
    elevatingGroup.add(breechBlock);

    // === RECOIL CYLINDERS (hydraulic dampeners) ===
    const recoilCylinderGeometry = new THREE.CylinderGeometry(0.04, 0.04, 1.2, 16);

    const leftRecoilCyl = new THREE.Mesh(recoilCylinderGeometry, metalDark);
    leftRecoilCyl.rotation.x = Math.PI / 2;
    leftRecoilCyl.position.set(-0.18, 0.12, 0.8);
    elevatingGroup.add(leftRecoilCyl);

    const rightRecoilCyl = new THREE.Mesh(recoilCylinderGeometry, metalDark);
    rightRecoilCyl.rotation.x = Math.PI / 2;
    rightRecoilCyl.position.set(0.18, 0.12, 0.8);
    elevatingGroup.add(rightRecoilCyl);

    // === EQUILIBRATORS (help balance barrel weight) ===
    const equilibratorGeometry = new THREE.CylinderGeometry(0.05, 0.06, 0.7, 16);

    const leftEquilibrator = new THREE.Mesh(equilibratorGeometry, metalMid);
    leftEquilibrator.position.set(-0.35, 0.3, -0.1);
    leftEquilibrator.rotation.z = 0.3;
    leftEquilibrator.rotation.x = -0.2;
    elevatingGroup.add(leftEquilibrator);

    const rightEquilibrator = new THREE.Mesh(equilibratorGeometry, metalMid);
    rightEquilibrator.position.set(0.35, 0.3, -0.1);
    rightEquilibrator.rotation.z = -0.3;
    rightEquilibrator.rotation.x = -0.2;
    elevatingGroup.add(rightEquilibrator);

    // === SHIELD (protective plate) ===
    const shieldGeometry = new THREE.BoxGeometry(1.4, 0.9, 0.04);
    const shield = new THREE.Mesh(shieldGeometry, metalMid);
    shield.position.set(0, 0.35, 0.5);
    shield.rotation.x = -0.15;
    elevatingGroup.add(shield);

    // Shield cutout for barrel (just visual detail)
    const shieldNotchGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.06, 16, 1, false, 0, Math.PI);
    const shieldNotch = new THREE.Mesh(shieldNotchGeometry, metalMid);
    shieldNotch.rotation.x = Math.PI / 2;
    shieldNotch.rotation.z = Math.PI;
    shieldNotch.position.set(0, -0.05, 0.52);
    elevatingGroup.add(shieldNotch);

    // === SIGHT (aiming device) ===
    const sightBaseGeometry = new THREE.BoxGeometry(0.08, 0.12, 0.08);
    const sightBase = new THREE.Mesh(sightBaseGeometry, metalDark);
    sightBase.position.set(0.25, 0.15, 0.25);
    elevatingGroup.add(sightBase);

    const sightTubeGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.15, 12);
    const sightTube = new THREE.Mesh(sightTubeGeometry, metalDark);
    sightTube.position.set(0.25, 0.27, 0.25);
    elevatingGroup.add(sightTube);

    // Camera orientation
    const lookAtTarget = new THREE.Vector3(
      CONFIG.camera.lookAt.x,
      CONFIG.camera.lookAt.y,
      CONFIG.camera.lookAt.z
    );
    const lookDirection = new THREE.Vector3()
      .subVectors(lookAtTarget, camera.position)
      .normalize();
    let yaw = Math.atan2(lookDirection.x, lookDirection.z) + Math.PI;
    let pitch = Math.asin(THREE.MathUtils.clamp(lookDirection.y, -1, 1));

    const maxPitch = THREE.MathUtils.degToRad(CONFIG.controls.maxPitchDeg);

    function applyCameraOrientation() {
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }
    applyCameraOrientation();

    // Mouse controls
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isDragging) return;
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      yaw -= dx * CONFIG.controls.lookSensitivity;
      pitch -= dy * CONFIG.controls.lookSensitivity;
      pitch = THREE.MathUtils.clamp(pitch, -maxPitch, maxPitch);
      applyCameraOrientation();
    });

    // Keyboard controls
    const pressedKeys = new Set();
    window.addEventListener('keydown', (event) => {
      pressedKeys.add(event.code);
    });
    window.addEventListener('keyup', (event) => {
      pressedKeys.delete(event.code);
    });

    // Movement vectors
    const moveVector = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);

    // Animation loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Calculate movement
      const moveForward = (pressedKeys.has('KeyW') ? 1 : 0) - (pressedKeys.has('KeyS') ? 1 : 0);
      const moveRight = (pressedKeys.has('KeyD') ? 1 : 0) - (pressedKeys.has('KeyA') ? 1 : 0);

      if (moveForward !== 0 || moveRight !== 0) {
        // Get camera forward direction (projected onto horizontal plane)
        camera.getWorldDirection(forwardVector);
        forwardVector.y = 0;
        forwardVector.normalize();

        // Get right vector (perpendicular to forward)
        rightVector.crossVectors(forwardVector, worldUp).normalize();

        // Build movement vector
        moveVector.set(0, 0, 0);
        moveVector.addScaledVector(forwardVector, moveForward);
        moveVector.addScaledVector(rightVector, moveRight);

        if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          camera.position.addScaledVector(moveVector, CONFIG.controls.moveSpeed * dt);
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
