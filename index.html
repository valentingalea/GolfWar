<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Three.js Regulation Shuffleboard Table</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; overflow:hidden; }
    #hud {
      position: fixed; left: 12px; top: 12px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: #d7e0ea; font-size: 13px; line-height: 1.35;
      background: rgba(10,14,20,0.55); border: 1px solid rgba(255,255,255,0.08);
      padding: 10px 12px; border-radius: 10px;
      backdrop-filter: blur(8px);
      max-width: 560px;
    }
    #hud b { color:#ffffff; }
    canvas { display:block; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <b>Shuffleboard physics debug</b><br/>
    Tune values, then press <b>Start</b> to apply an impulse to the puck (along +Z). Use <b>Reset</b> to retry.
    <div style="margin-top:10px; display:grid; grid-template-columns: 150px 1fr; gap:8px 10px; align-items:center;">
      <label for="gravity">Gravity (m/s², Y-)</label>
      <input id="gravity" type="number" step="0.1" />

      <label for="mass">Puck mass (kg)</label>
      <input id="mass" type="number" step="0.05" />

      <label for="friction">Friction (μ)</label>
      <input id="friction" type="number" step="0.01" />

      <label for="impulse">Initial impulse (N·s)</label>
      <input id="impulse" type="number" step="0.1" />

      <div></div>
      <button id="startBtn" style="
        padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.08); color:#fff; font-weight:600; cursor:pointer;
      ">Start</button>
      <button id="resetBtn" style="
        padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.05); color:#fff; font-weight:600; cursor:pointer;
      ">Reset</button>
    </div>

    <div id="readout" style="margin-top:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px; white-space:pre;"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // Units: meters
    const IN = 0.0254;
    const FT = 0.3048;

    // 22ft table, common proportions
    const specs = {
      overallLen: 22 * FT,             // 6.7056
      overallWidth: 31 * IN,           // 0.7874
      height: 30 * IN,                 // 0.762
      playLen: (22 * FT) - (16 * IN),  // ~6.2992
      playWidth: 20 * IN,              // 0.508
      playThickness: 3 * IN,           // 0.0762
      bumperDepth: 1.2 * IN,
      railTopHeight: 2.2 * IN,
      gutterDepth: 1.2 * IN
    };

    const halfPlayLen = specs.playLen * 0.5;
    const halfPlayW   = specs.playWidth * 0.5;
    const halfOverallW= specs.overallWidth * 0.5;

    // Scoring layout (typical): 3 zone 6", 2 zone 6", foul line 6ft from end
    const scoring = {
      zone3: 6 * IN,
      zone2: 6 * IN,
      foulFromEnd: 6 * FT
    };

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // --- Scene ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 10, 70);

    // --- Camera ---
    // Starting camera position: similar to the previous version after ~2 scroll-wheel zoom steps.
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.05, 300);
    const camZ = -halfPlayLen - 0.55; // was -1.2; closer by default
    camera.position.set(0, specs.height + 0.32, camZ);
    camera.lookAt(0, specs.height + 0.12, halfPlayLen * 0.70);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.target.set(0, specs.height + 0.11, halfPlayLen * 0.45);
    controls.minDistance = 1.6;
    controls.maxDistance = 28;
    controls.maxPolarAngle = Math.PI * 0.49;
    const followCamState = {
      active: false,
      offset: new THREE.Vector3(),
      target: controls.target.clone(),
      velocity: new THREE.Vector3(),
      bounds: {
        minZ: -halfPlayLen + 0.35,
        maxZ: halfPlayLen - 0.35
      }
    };

    // --- Lights (brighter ambient) ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));
    scene.add(new THREE.HemisphereLight(0xcfe2ff, 0x1a2533, 1.05));

    const key = new THREE.DirectionalLight(0xffffff, 1.15);
    key.position.set(6.0, 7.0, -2.0);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.left = -10;
    key.shadow.camera.right = 10;
    key.shadow.camera.top = 10;
    key.shadow.camera.bottom = -10;
    key.shadow.camera.near = 0.5;
    key.shadow.camera.far = 70;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xaed1ff, 0.60);
    fill.position.set(-6.0, 4.0, 6.5);
    scene.add(fill);

    // --- Ground ---
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(120, 120),
      new THREE.MeshStandardMaterial({ color: 0x0f1722, roughness: 1.0, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- Table group ---
    const table = new THREE.Group();
    scene.add(table);

    // Materials
    const woodCabinet = new THREE.MeshStandardMaterial({ color: 0x2c221a, roughness: 0.85, metalness: 0.04 });
    const woodFrame   = new THREE.MeshStandardMaterial({ color: 0x3b2a1d, roughness: 0.75, metalness: 0.04 });
    const woodPlay    = new THREE.MeshStandardMaterial({ color: 0xa3693b, roughness: 0.36, metalness: 0.05 });
    const woodGutter  = new THREE.MeshStandardMaterial({ color: 0x3a2a1f, roughness: 0.90, metalness: 0.02 });

    // Cabinet base
    const base = new THREE.Mesh(
      new THREE.BoxGeometry(specs.overallWidth, specs.height, specs.overallLen),
      woodCabinet
    );
    base.position.set(0, specs.height * 0.5, 0);
    base.castShadow = true;
    base.receiveShadow = true;
    table.add(base);

    // Playfield slab (wood underlay)
    const playSlab = new THREE.Mesh(
      new THREE.BoxGeometry(specs.playWidth, specs.playThickness, specs.playLen),
      woodPlay
    );
    playSlab.position.set(0, specs.height + specs.playThickness * 0.5, 0);
    playSlab.castShadow = true;
    playSlab.receiveShadow = true;
    table.add(playSlab);


    // Top surface Y (used for markings/pucks)
    const topY = playSlab.position.y + specs.playThickness * 0.5;

    // --- Replace the SOLID "frameTop slab" with an OPEN frame made from 4 pieces ---
    const frameTopThickness = 1.6 * IN;
    const sideGap = (specs.overallWidth - specs.playWidth) * 0.5;
    const frameTopY = playSlab.position.y + specs.playThickness * 0.5 + frameTopThickness * 0.5;

    // Side frame strips (left/right)
    const sideStripGeom = new THREE.BoxGeometry(sideGap, frameTopThickness, specs.playLen);
    const leftStrip = new THREE.Mesh(sideStripGeom, woodFrame);
    leftStrip.position.set(-(halfPlayW + sideGap * 0.5), frameTopY, 0);
    leftStrip.castShadow = true; leftStrip.receiveShadow = true;
    table.add(leftStrip);

    const rightStrip = leftStrip.clone();
    rightStrip.position.x *= -1;
    table.add(rightStrip);

    // End frame strips (near/far) — span full width (including side strips),
    // but only small thickness along Z to "cap" the ends.
    const endStripDepth = 6 * IN; // ~6" cap visible
    const endStripGeom = new THREE.BoxGeometry(specs.overallWidth, frameTopThickness, endStripDepth);
    const nearStrip = new THREE.Mesh(endStripGeom, woodFrame);
    nearStrip.position.set(0, frameTopY, -halfPlayLen + endStripDepth * 0.5);
    nearStrip.castShadow = true; nearStrip.receiveShadow = true;
    table.add(nearStrip);

    const farStrip = nearStrip.clone();
    farStrip.position.z = halfPlayLen - endStripDepth * 0.5;
    table.add(farStrip);

    // Rails + gutters sit "inside" the open frame region
    const railYTop = frameTopY + frameTopThickness * 0.5;

    const gutterFloorY = (playSlab.position.y + specs.playThickness * 0.5) - specs.gutterDepth;
    const railThickness = sideGap * 0.55;
    const gutterWidth = sideGap - railThickness;

    const railGeom = new THREE.BoxGeometry(railThickness, specs.railTopHeight, specs.playLen);

    const leftRail = new THREE.Mesh(railGeom, woodFrame);
    leftRail.position.set(-(halfPlayW + gutterWidth + railThickness * 0.5), railYTop - specs.railTopHeight * 0.5, 0);
    leftRail.castShadow = true; leftRail.receiveShadow = true;
    table.add(leftRail);

    const rightRail = leftRail.clone();
    rightRail.position.x *= -1;
    table.add(rightRail);

    const gutterGeom = new THREE.BoxGeometry(gutterWidth, specs.gutterDepth, specs.playLen);

    const leftGutter = new THREE.Mesh(gutterGeom, woodGutter);
    leftGutter.position.set(-(halfPlayW + gutterWidth * 0.5), gutterFloorY + specs.gutterDepth * 0.5, 0);
    leftGutter.receiveShadow = true;
    table.add(leftGutter);

    const rightGutter = leftGutter.clone();
    rightGutter.position.x *= -1;
    table.add(rightGutter);

    // End bumpers (small lips beyond playfield)
    const bumperH = 1.2 * IN;
    const bumperGeom = new THREE.BoxGeometry(specs.overallWidth, bumperH, specs.bumperDepth);

    const bumperNear = new THREE.Mesh(bumperGeom, woodFrame);
    bumperNear.position.set(0, railYTop - bumperH * 0.5, -halfPlayLen - specs.bumperDepth * 0.5);
    bumperNear.castShadow = true; bumperNear.receiveShadow = true;
    table.add(bumperNear);

    const bumperFar = bumperNear.clone();
    bumperFar.position.z = halfPlayLen + specs.bumperDepth * 0.5;
    table.add(bumperFar);
    // (Texture projection removed — using the plain wood playfield + drawn lines.)

    // --- Markings (thin boxes, properly spaced) ---
    const markings = new THREE.Group();
    markings.position.y = topY + 0.004;
    table.add(markings);

    const lineMat = new THREE.MeshStandardMaterial({ color: 0xf0d7b6, roughness: 0.95, metalness: 0.0 });

    function lineAcross(z, thickness = 0.006) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(specs.playWidth, 0.002, thickness), lineMat);
      m.position.set(0, 0, z);
      markings.add(m);
      return m;
    }

    function centerLine(thickness = 0.004) {
      const m = new THREE.Mesh(new THREE.BoxGeometry(thickness, 0.002, specs.playLen * 0.995), lineMat);
      m.position.set(0, 0, 0);
      markings.add(m);
      return m;
    }

    function endSet(endSign) {
      const endZ = endSign * halfPlayLen;
      const safeEnd = endZ - endSign * 0.02; // avoid edge overlap

      const z3 = safeEnd - endSign * scoring.zone3;
      const z2 = safeEnd - endSign * (scoring.zone3 + scoring.zone2);
      const zF = safeEnd - endSign * scoring.foulFromEnd;

      lineAcross(z3, 0.010);
      lineAcross(z2, 0.010);
      lineAcross(zF, 0.014);

      // side ticks
      const tickLen = 0.10;
      const tickTh  = 0.010;
      [z3, z2, zF].forEach((z) => {
        const left = new THREE.Mesh(new THREE.BoxGeometry(tickLen, 0.002, tickTh), lineMat);
        left.position.set(-(halfPlayW - tickLen * 0.5), 0, z);
        markings.add(left);

        const right = left.clone();
        right.position.x *= -1;
        markings.add(right);
      });

      return { zF };
    }

    centerLine();
    endSet(+1);
    const near = endSet(-1);

    // Starting line near camera end
    const nearEndZ = -halfPlayLen;
    const startLineZ = nearEndZ + 0.55;
    lineAcross(startLineZ, 0.012);

    // --- Reference axis tripod (X=red, Y=green, Z=blue) ---
    // On top of the table, left of the starting area.
    const axes = new THREE.AxesHelper(0.22);
    axes.position.set(-(halfPlayW + 0.12), topY + 0.10, startLineZ - 0.10);
    scene.add(axes);

    function makeAxisLabel(text) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,size,size);
      ctx.font = 'bold 72px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#ffffff';
      ctx.fillText(text, size/2, size/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      return new THREE.Mesh(new THREE.PlaneGeometry(0.08, 0.08), mat);
    }

    const xLab = makeAxisLabel('X'); xLab.position.copy(axes.position).add(new THREE.Vector3(0.26, 0.00, 0.00));
    const yLab = makeAxisLabel('Y'); yLab.position.copy(axes.position).add(new THREE.Vector3(0.00, 0.26, 0.00));
    const zLab = makeAxisLabel('Z'); zLab.position.copy(axes.position).add(new THREE.Vector3(0.00, 0.00, 0.26));
    scene.add(xLab, yLab, zLab);

    
    // --- Zone numbers as sprites ---
    function makeTextSprite(text) {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,size,size);
      ctx.font = 'bold 150px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#f0d7b6';
      ctx.fillText(text, size/2, size/2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.18, 0.18), mat);
      plane.rotation.x = -Math.PI / 2;
      return plane;
    }

    function addZoneNumbers(endSign) {
      const endZ = endSign * halfPlayLen;
      const safeEnd = endZ - endSign * 0.02;

      const c3 = safeEnd - endSign * (scoring.zone3 * 0.5);
      const c2 = safeEnd - endSign * (scoring.zone3 + scoring.zone2 * 0.5);
      const c1 = safeEnd - endSign * (scoring.zone3 + scoring.zone2 + (scoring.foulFromEnd - (scoring.zone3 + scoring.zone2)) * 0.5);

      const y = topY + 0.0025;
      const s3 = makeTextSprite('3'); s3.position.set(0, y, c3);
      const s2 = makeTextSprite('2'); s2.position.set(0, y, c2);
      const s1 = makeTextSprite('1'); s1.position.set(0, y, c1);
      table.add(s3, s2, s1);
    }

    addZoneNumbers(-1);
    addZoneNumbers(+1);

    // --- Pucks (regulation-ish) ---
    const puck = {
      diameter: (2 + 5/16) * IN,
      thickness: 0.55 * IN
    };
    const puckR = puck.diameter * 0.5;
    const puckSurfaceY = topY + puck.thickness * 0.5;

    const puckGeom = new THREE.CylinderGeometry(puckR, puckR, puck.thickness, 48);
    const puckRed  = new THREE.MeshStandardMaterial({ color: 0xbf2f2f, roughness: 0.22, metalness: 0.42 });
    const puckBlue = new THREE.MeshStandardMaterial({ color: 0x2f66bf, roughness: 0.22, metalness: 0.42 });

    function makePuck(mat) {
      const m = new THREE.Mesh(puckGeom, mat);
      // Cylinder axis is Y -> already "flat" on the board.
      m.castShadow = true;
      m.receiveShadow = true;
      return m;
    }

    const puckY = puckSurfaceY;

    const p0 = makePuck(puckRed);
    p0.position.set(0, puckY, startLineZ);
    table.add(p0);

    const sideX = (halfPlayW - puckR - 0.010);
    const spacing = puck.diameter * 1.35;
    const p1 = makePuck(puckBlue); p1.position.set(sideX, puckY, startLineZ - spacing * 1);
    const p2 = makePuck(puckBlue); p2.position.set(sideX, puckY, startLineZ - spacing * 2);
    const p3 = makePuck(puckBlue); p3.position.set(sideX, puckY, startLineZ - spacing * 3);
    table.add(p1, p2, p3);

    // --- Physics (cannon-es) ---
    // Goal: a puck that slides realistically with low friction, no bounce.
    const world = new CANNON.World({
      gravity: new CANNON.Vec3(0, -9.82, 0),
      allowSleep: true
    });

    const tableMat = new CANNON.Material('table');
    const puckMatPhys = new CANNON.Material('puck');

    // Tweak friction to get a "shuffleboard-ish" glide distance on a ~6.3m playfield.
    // Higher friction -> shorter travel. Lower -> longer.
    const contact = new CANNON.ContactMaterial(tableMat, puckMatPhys, {
      friction: 0.05,
      restitution: 0.0
    });
    world.defaultContactMaterial.friction = 0.05;
    world.addContactMaterial(contact);

    // Table top plane (static)
    const tablePlaneShape = new CANNON.Plane();
    const tablePlaneBody = new CANNON.Body({ mass: 0, material: tableMat });
    tablePlaneBody.addShape(tablePlaneShape);
    // Cannon plane is infinite, normal +Z by default; rotate so normal is +Y.
    tablePlaneBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    tablePlaneBody.position.set(0, topY, 0);
    world.addBody(tablePlaneBody);

    // Dynamic puck body for the starting puck (p0)
    // Approx mass for a shuffleboard weight: ~0.4–0.6kg. We'll use 0.5kg.
    const puckMass = 0.5;

    // Use a thin BOX for stability (avoids cylinder-orientation issues and prevents "standing up").
    const puckShape = new CANNON.Box(new CANNON.Vec3(puckR, puck.thickness * 0.5, puckR));
    const puckBody = new CANNON.Body({
      mass: puckMass,
      material: puckMatPhys,
      linearDamping: 0.015,
      angularDamping: 0.95
    });
    puckBody.addShape(puckShape);

    // Spawn directly on the play surface; we'll clamp Y to avoid any vertical launch.
    puckBody.position.set(p0.position.x, puckSurfaceY, p0.position.z);

    // Prevent tipping: allow yaw only.
    puckBody.angularFactor.set(0, 1, 0);

    puckBody.sleepSpeedLimit = 0.05;
    puckBody.sleepTimeLimit = 0.4;
    world.addBody(puckBody);

    // Controlled via UI: press Start to apply impulse down-table (+Z).

    // Fixed-step physics
    const fixedTimeStep = 1 / 60;
    const maxSubSteps = 8; // more substeps reduces tunneling at higher speeds

    // --- UI defaults / wiring ---
    const ui = {
      gravity: document.getElementById('gravity'),
      mass: document.getElementById('mass'),
      friction: document.getElementById('friction'),
      impulse: document.getElementById('impulse'),
      startBtn: document.getElementById('startBtn'),
      resetBtn: document.getElementById('resetBtn'),
      readout: document.getElementById('readout')
    };

    // Defaults (match current sim)
    ui.gravity.value = 9.82;
    ui.mass.value = puckMass.toFixed(2);
    ui.friction.value = 0.05;
    ui.impulse.value = 0.1;

    // Helper to apply UI values to physics
    function applyParamsFromUI() {
      const g = Number(ui.gravity.value);
      const m = Number(ui.mass.value);
      const mu = Number(ui.friction.value);

      world.gravity.set(0, -Math.max(0, g), 0);
      // Update mass
      puckBody.mass = Math.max(0.01, m);
      puckBody.updateMassProperties();

      // Update friction: contact material + default
      contact.friction = mu;
      world.defaultContactMaterial.friction = mu;
    }

    // Reset puck to start line pose
    function resetPuckPose() {
      puckBody.velocity.set(0, 0, 0);
      puckBody.angularVelocity.set(0, 0, 0);
      puckBody.force.set(0, 0, 0);
      puckBody.torque.set(0, 0, 0);
      puckBody.quaternion.set(0, 0, 0, 1);

      // Seat the puck directly on the table surface.
      puckBody.position.set(p0.position.x, puckSurfaceY, p0.position.z);

      puckBody.wakeUp();

      // Sync visual immediately (so it's visible at start)
      p0.position.set(puckBody.position.x, puckBody.position.y, puckBody.position.z);
      p0.quaternion.set(puckBody.quaternion.x, puckBody.quaternion.y, puckBody.quaternion.z, puckBody.quaternion.w);
    }

    function keepPuckOnTable() {
      // Prevent any upward kick: clamp Y and zero vertical forces/velocity.
      puckBody.position.y = puckSurfaceY;
      puckBody.velocity.y = 0;
      puckBody.force.y = 0;
    }

    // Initialize: rest the puck on the table without any motion.
    resetPuckPose();
    puckBody.sleep();

    // Apply an impulse in +Z direction.
    let lastImpulse = {x:0,y:0,z:0};
    const followSpring = {
      stiffness: 14,
      damping: 2.4
    };

    function beginCameraFollow() {
      followCamState.active = true;
      followCamState.offset.copy(camera.position).sub(p0.position);
      followCamState.target.copy(controls.target);
      followCamState.velocity.set(0, 0, 0);
    }

    function updateCameraFollow(currentSpeed, dt) {
      if (!followCamState.active) return;

      // When the puck settles, stop following so the user regains full control.
      if (currentSpeed < 0.02 && puckBody.sleepState === CANNON.Body.SLEEPING) {
        followCamState.active = false;
        return;
      }

      const desired = new THREE.Vector3(
        puckBody.position.x,
        controls.target.y,
        THREE.MathUtils.clamp(puckBody.position.z, followCamState.bounds.minZ, followCamState.bounds.maxZ)
      );

      // Critically-damped-ish spring toward the puck.
      const delta = desired.clone().sub(followCamState.target);
      followCamState.velocity.addScaledVector(delta, followSpring.stiffness * dt);
      followCamState.velocity.multiplyScalar(Math.exp(-followSpring.damping * dt));
      followCamState.target.addScaledVector(followCamState.velocity, dt);

      controls.target.copy(followCamState.target);
      camera.position.copy(followCamState.target).add(followCamState.offset);
    }

    function startShot() {
      applyParamsFromUI();
      resetPuckPose();
      keepPuckOnTable();

      const J = Math.max(0, Number(ui.impulse.value)); // N*s
      // Impulse = m*v. For m=0.5kg, J=1.2 => v=2.4 m/s.
      const impulse = new CANNON.Vec3(0, 0, J);
      lastImpulse = {x: impulse.x, y: impulse.y, z: impulse.z};
      puckBody.applyImpulse(impulse, puckBody.position);
      keepPuckOnTable();
      beginCameraFollow();
    }

    ui.startBtn.addEventListener('click', startShot);
    ui.resetBtn?.addEventListener('click', () => { window.location.reload(); });

    const sheen = new THREE.Mesh(
      new THREE.PlaneGeometry(specs.playWidth * 0.58, specs.playLen * 0.98),
      new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.15, metalness: 0.0, transparent: true, opacity: 0.05 })
    );
    sheen.rotation.x = -Math.PI/2;
    sheen.position.set(0, topY + 0.0045, 0);
    table.add(sheen);

    // --- Animation ---
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);

      const dt = clock.getDelta();
      world.step(fixedTimeStep, dt, maxSubSteps);
      keepPuckOnTable();

      // Sync the visual puck mesh with its physics body
      p0.position.set(puckBody.position.x, puckBody.position.y, puckBody.position.z);
      p0.quaternion.set(puckBody.quaternion.x, puckBody.quaternion.y, puckBody.quaternion.z, puckBody.quaternion.w);

      const v = puckBody.velocity;
      const p = puckBody.position;
      const speed = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
      updateCameraFollow(speed, dt);

      // Debug readout
      if (ui?.readout) {
        ui.readout.textContent =
`puck pos (m):  x=${p.x.toFixed(3)}  y=${p.y.toFixed(3)}  z=${p.z.toFixed(3)}
puck vel (m/s): x=${v.x.toFixed(3)}  y=${v.y.toFixed(3)}  z=${v.z.toFixed(3)}  |v|=${speed.toFixed(3)}
params: g=${(-world.gravity.y).toFixed(2)}  mass=${puckBody.mass.toFixed(3)}  friction=${contact.friction.toFixed(3)}
tip-lock: angularFactor=[${puckBody.angularFactor.x.toFixed(0)},${puckBody.angularFactor.y.toFixed(0)},${puckBody.angularFactor.z.toFixed(0)}]
last impulse (N·s): x=${lastImpulse.x.toFixed(3)} y=${lastImpulse.y.toFixed(3)} z=${lastImpulse.z.toFixed(3)}`;
      }

      xLab.lookAt(camera.position);
      yLab.lookAt(camera.position);
      zLab.lookAt(camera.position);

      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // --- Resize ---
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
