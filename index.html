<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Scene</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f14;
      overflow: hidden;
    }
    canvas { display: block; }
    #hud {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 12px 14px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      font-family: monospace;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }
    .hud-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .hud-label {
      flex: 1;
    }
    .hud-value {
      min-width: 50px;
      text-align: center;
      background: rgba(255,255,255,0.1);
      padding: 2px 6px;
      border-radius: 4px;
    }
    .hud-btn {
      width: 28px;
      height: 28px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .hud-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    .hud-btn:active {
      background: rgba(255,255,255,0.3);
    }
    .hud-input {
      width: 60px;
      padding: 4px 6px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    .hud-unit {
      font-size: 11px;
      color: rgba(255,255,255,0.6);
    }
    .fire-btn {
      width: 100%;
      background: rgba(200, 60, 60, 0.7);
      font-weight: bold;
    }
    .fire-btn:hover {
      background: rgba(220, 80, 80, 0.8);
    }
    .fire-btn:active {
      background: rgba(255, 100, 100, 0.9);
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div class="hud-row">
      <span class="hud-label">Rotation</span>
      <span id="rotationValue" class="hud-value">0째</span>
      <button id="rotLeft" class="hud-btn">&lt;</button>
      <button id="rotRight" class="hud-btn">&gt;</button>
    </div>
    <div class="hud-row">
      <span class="hud-label">Elevation</span>
      <span id="elevationValue" class="hud-value">40째</span>
      <button id="elevDown" class="hud-btn">-</button>
      <button id="elevUp" class="hud-btn">+</button>
    </div>
    <div class="hud-row">
      <span class="hud-label">Velocity</span>
      <input id="velocityInput" class="hud-input" type="number" value="20" min="10" max="200" step="5" />
      <span class="hud-unit">m/s</span>
    </div>
    <div class="hud-row">
      <span class="hud-label">Mass</span>
      <input id="massInput" class="hud-input" type="number" value="10" min="1" max="100" step="1" />
      <span class="hud-unit">kg</span>
    </div>
    <div class="hud-row">
      <span class="hud-label">Inner Recoil</span>
      <input id="recoilSpeedInput" class="hud-input" type="number" value="2" min="1" max="20" step="1" />
      <span class="hud-unit"></span>
    </div>
    <div class="hud-row">
      <span class="hud-label">Outer Recoil</span>
      <input id="outerRecoilSpeedInput" class="hud-input" type="number" value="4" min="1" max="20" step="1" />
      <span class="hud-unit"></span>
    </div>
    <div class="hud-row">
      <button id="fireBtn" class="hud-btn fire-btn">FIRE</button>
    </div>
  </div>
  <script type="module">
    import * as THREE from 'three';

    const CONFIG = {
      camera: {
        fov: 65,
        near: 0.1,
        far: 500,
        position: { x: 0, y: 1.65, z: 5 },
        lookAt: { x: 0, y: 0, z: 0 }
      },
      ground: {
        size: 1000,
        tileSize: 1,
        colorA: '#3a3a3a',
        colorB: '#2a2a2a'
      },
      axis: {
        origin: { x: 0, y: 0.5, z: 0 },
        size: 2,
        labelOffset: 2.3,
        labelSize: 0.3
      },
      controls: {
        lookSensitivity: 0.003,
        maxPitchDeg: 89,
        moveSpeed: 5.0
      }
    };

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      CONFIG.camera.fov,
      window.innerWidth / window.innerHeight,
      CONFIG.camera.near,
      CONFIG.camera.far
    );
    camera.position.set(
      CONFIG.camera.position.x,
      CONFIG.camera.position.y,
      CONFIG.camera.position.z
    );
    camera.rotation.order = 'YXZ';

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    scene.add(directionalLight);

    // Create checkerboard texture
    function createCheckerTexture() {
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const square = size / 2;
      ctx.fillStyle = CONFIG.ground.colorA;
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = CONFIG.ground.colorB;
      ctx.fillRect(0, 0, square, square);
      ctx.fillRect(square, square, square, square);

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      const repeat = CONFIG.ground.size / CONFIG.ground.tileSize;
      texture.repeat.set(repeat, repeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return texture;
    }

    // Ground plane
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(CONFIG.ground.size, CONFIG.ground.size),
      new THREE.MeshStandardMaterial({
        map: createCheckerTexture(),
        roughness: 0.9,
        metalness: 0.1
      })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // Axis helper at origin
    const axisOrigin = new THREE.Vector3(
      CONFIG.axis.origin.x,
      CONFIG.axis.origin.y,
      CONFIG.axis.origin.z
    );

    // Create custom axis lines
    function createAxisLine(direction, color, length) {
      const material = new THREE.LineBasicMaterial({ color });
      const points = [
        axisOrigin.clone(),
        axisOrigin.clone().add(direction.clone().multiplyScalar(length))
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      return new THREE.Line(geometry, material);
    }

    const xAxis = createAxisLine(new THREE.Vector3(1, 0, 0), 0xff4444, CONFIG.axis.size);
    const yAxis = createAxisLine(new THREE.Vector3(0, 1, 0), 0x44ff44, CONFIG.axis.size);
    const zAxis = createAxisLine(new THREE.Vector3(0, 0, 1), 0x4444ff, CONFIG.axis.size);
    scene.add(xAxis, yAxis, zAxis);

    // Create axis labels
    function makeAxisLabel(text, color) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.font = 'bold 80px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = color;
      ctx.fillText(text, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(CONFIG.axis.labelSize, CONFIG.axis.labelSize, 1);
      return sprite;
    }

    const labelX = makeAxisLabel('X', '#ff4444');
    const labelY = makeAxisLabel('Y', '#44ff44');
    const labelZ = makeAxisLabel('Z', '#4444ff');

    labelX.position.copy(axisOrigin).add(new THREE.Vector3(CONFIG.axis.labelOffset, 0, 0));
    labelY.position.copy(axisOrigin).add(new THREE.Vector3(0, CONFIG.axis.labelOffset, 0));
    labelZ.position.copy(axisOrigin).add(new THREE.Vector3(0, 0, CONFIG.axis.labelOffset));

    scene.add(labelX, labelY, labelZ);

    // ========== HOWITZER MODEL ==========
    const howitzer = new THREE.Group();
    howitzer.position.set(3, 0, 0);
    howitzer.rotation.y = Math.PI; // Rotate 180 to face camera forward direction
    howitzer.scale.setScalar(1.2); // Scale up 20% for military presence
    scene.add(howitzer);

    // Carriage group - moves during recoil (wheels, body, turret)
    const carriageGroup = new THREE.Group();
    howitzer.add(carriageGroup);

    // Materials
    const metalDark = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.6, metalness: 0.4 });
    const metalMid = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.5, metalness: 0.5 });
    const metalLight = new THREE.MeshStandardMaterial({ color: 0x6a6a6a, roughness: 0.4, metalness: 0.6 });
    const rubber = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9, metalness: 0.0 });

    // === WHEELS ===
    const wheelRadius = 0.5;
    const wheelWidth = 0.28; // Wider, chunkier wheels
    const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth, 32);

    // Wheel with hub detail
    function createWheel() {
      const wheelGroup = new THREE.Group();

      // Tire
      const tire = new THREE.Mesh(wheelGeometry, rubber);
      tire.rotation.z = Math.PI / 2;
      wheelGroup.add(tire);

      // Hub
      const hubGeometry = new THREE.CylinderGeometry(0.15, 0.15, wheelWidth + 0.02, 16);
      const hub = new THREE.Mesh(hubGeometry, metalMid);
      hub.rotation.z = Math.PI / 2;
      wheelGroup.add(hub);

      // Spokes
      const spokeGeometry = new THREE.BoxGeometry(0.04, wheelRadius * 1.6, 0.03);
      for (let i = 0; i < 6; i++) {
        const spoke = new THREE.Mesh(spokeGeometry, metalMid);
        spoke.rotation.x = (i / 6) * Math.PI;
        wheelGroup.add(spoke);
      }

      return wheelGroup;
    }

    const leftWheel = createWheel();
    leftWheel.position.set(-0.9, wheelRadius, 0.3);
    carriageGroup.add(leftWheel);

    const rightWheel = createWheel();
    rightWheel.position.set(0.9, wheelRadius, 0.3);
    carriageGroup.add(rightWheel);

    // Axle
    const axleGeometry = new THREE.CylinderGeometry(0.06, 0.06, 2.0, 16);
    const axle = new THREE.Mesh(axleGeometry, metalDark);
    axle.rotation.z = Math.PI / 2;
    axle.position.set(0, wheelRadius, 0.3);
    carriageGroup.add(axle);

    // === TRAILS (legs with spades) ===
    function createTrail(side) {
      const trailGroup = new THREE.Group();

      // Main trail beam
      const beamGeometry = new THREE.BoxGeometry(0.12, 0.15, 2.5);
      const beam = new THREE.Mesh(beamGeometry, metalMid);
      beam.position.set(0, 0.08, -1.25);
      trailGroup.add(beam);

      // Spade (anti-recoil plate that digs into ground)
      const spadeGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.05);
      const spade = new THREE.Mesh(spadeGeometry, metalDark);
      spade.position.set(0, 0.1, -2.5);
      spade.rotation.x = -0.3; // Angled to dig in
      trailGroup.add(spade);

      // Spade spike
      const spikeGeometry = new THREE.ConeGeometry(0.06, 0.2, 8);
      const spike = new THREE.Mesh(spikeGeometry, metalDark);
      spike.position.set(0, -0.05, -2.55);
      spike.rotation.x = Math.PI / 2;
      trailGroup.add(spike);

      trailGroup.position.x = side * 0.5;
      return trailGroup;
    }

    howitzer.add(createTrail(-1)); // Left trail
    howitzer.add(createTrail(1));  // Right trail

    // Trail cross-brace
    const braceGeometry = new THREE.BoxGeometry(1.1, 0.08, 0.08);
    const brace = new THREE.Mesh(braceGeometry, metalMid);
    brace.position.set(0, 0.12, -1.8);
    howitzer.add(brace);

    // === CARRIAGE (main body) ===
    const carriageGeometry = new THREE.BoxGeometry(0.9, 0.35, 0.8);
    const carriage = new THREE.Mesh(carriageGeometry, metalMid);
    carriage.position.set(0, 0.45, 0.1);
    carriageGroup.add(carriage);

    // Carriage top plate
    const topPlateGeometry = new THREE.BoxGeometry(0.7, 0.08, 0.6);
    const topPlate = new THREE.Mesh(topPlateGeometry, metalLight);
    topPlate.position.set(0, 0.65, 0.1);
    carriageGroup.add(topPlate);

    // === TURRET GROUP (rotates on base) ===
    const turretGroup = new THREE.Group();
    turretGroup.position.set(0, 0.75, 0.1);
    carriageGroup.add(turretGroup);

    // Pivot base (part of turret)
    const pivotBaseGeometry = new THREE.CylinderGeometry(0.25, 0.3, 0.2, 24);
    const pivotBase = new THREE.Mesh(pivotBaseGeometry, metalLight);
    pivotBase.position.set(0, 0, 0);
    turretGroup.add(pivotBase);

    // === ELEVATING GROUP (barrel assembly that tilts) ===
    const elevatingGroup = new THREE.Group();
    elevatingGroup.position.set(0, 0.1, 0);
    // Set elevation to 40 degrees
    elevatingGroup.rotation.x = -THREE.MathUtils.degToRad(40);
    turretGroup.add(elevatingGroup);

    // Cradle (holds the barrel)
    const cradleGeometry = new THREE.BoxGeometry(0.5, 0.25, 0.8);
    const cradle = new THREE.Mesh(cradleGeometry, metalMid);
    cradle.position.set(0, 0, 0.2);
    elevatingGroup.add(cradle);

    // === BARREL ASSEMBLY (piston mechanism) ===
    // Outer cylinder (recoil housing/recuperator)
    const outerBarrelRadius = 0.14;
    const outerBarrelLength = 1.8;
    const outerBarrelGeometry = new THREE.CylinderGeometry(
      outerBarrelRadius, outerBarrelRadius * 1.1, outerBarrelLength, 32
    );
    const outerBarrel = new THREE.Mesh(outerBarrelGeometry, metalMid);
    outerBarrel.rotation.x = Math.PI / 2;
    outerBarrel.position.set(0, 0.05, outerBarrelLength / 2 + 0.3);
    elevatingGroup.add(outerBarrel);
    const outerBarrelBaseZ = outerBarrel.position.z;

    // Inner cylinder (actual barrel - slides back on recoil)
    const innerBarrelRadius = 0.09;
    const innerBarrelLength = 2.2;
    const innerBarrelGeometry = new THREE.CylinderGeometry(
      innerBarrelRadius, innerBarrelRadius, innerBarrelLength, 32
    );
    const innerBarrel = new THREE.Mesh(innerBarrelGeometry, metalLight);
    innerBarrel.rotation.x = Math.PI / 2;
    innerBarrel.position.set(0, 0.05, innerBarrelLength / 2 + 0.6);
    elevatingGroup.add(innerBarrel);

    // Store base position for recoil animation
    const innerBarrelBaseZ = innerBarrel.position.z;

    // Muzzle brake (at tip of barrel) - moves with inner barrel
    const muzzleBrakeGeometry = new THREE.CylinderGeometry(0.12, 0.11, 0.25, 32);
    const muzzleBrake = new THREE.Mesh(muzzleBrakeGeometry, metalDark);
    muzzleBrake.rotation.x = Math.PI / 2;
    muzzleBrake.position.set(0, 0.05, innerBarrelLength + 0.75);
    elevatingGroup.add(muzzleBrake);
    const muzzleBrakeBaseZ = muzzleBrake.position.z;

    // Breech (back of barrel)
    const breechGeometry = new THREE.CylinderGeometry(0.16, 0.18, 0.35, 32);
    const breech = new THREE.Mesh(breechGeometry, metalDark);
    breech.rotation.x = Math.PI / 2;
    breech.position.set(0, 0.05, 0);
    elevatingGroup.add(breech);

    // Breech block
    const breechBlockGeometry = new THREE.BoxGeometry(0.22, 0.22, 0.12);
    const breechBlock = new THREE.Mesh(breechBlockGeometry, metalDark);
    breechBlock.position.set(0, 0.05, -0.15);
    elevatingGroup.add(breechBlock);

    // === RECOIL CYLINDERS (hydraulic dampeners) ===
    const recoilCylinderGeometry = new THREE.CylinderGeometry(0.04, 0.04, 1.2, 16);

    const leftRecoilCyl = new THREE.Mesh(recoilCylinderGeometry, metalDark);
    leftRecoilCyl.rotation.x = Math.PI / 2;
    leftRecoilCyl.position.set(-0.18, 0.12, 0.8);
    elevatingGroup.add(leftRecoilCyl);

    const rightRecoilCyl = new THREE.Mesh(recoilCylinderGeometry, metalDark);
    rightRecoilCyl.rotation.x = Math.PI / 2;
    rightRecoilCyl.position.set(0.18, 0.12, 0.8);
    elevatingGroup.add(rightRecoilCyl);

    // === EQUILIBRATORS (help balance barrel weight) ===
    const equilibratorGeometry = new THREE.CylinderGeometry(0.05, 0.06, 0.7, 16);

    const leftEquilibrator = new THREE.Mesh(equilibratorGeometry, metalMid);
    leftEquilibrator.position.set(-0.35, 0.3, -0.1);
    leftEquilibrator.rotation.z = 0.3;
    leftEquilibrator.rotation.x = -0.2;
    elevatingGroup.add(leftEquilibrator);

    const rightEquilibrator = new THREE.Mesh(equilibratorGeometry, metalMid);
    rightEquilibrator.position.set(0.35, 0.3, -0.1);
    rightEquilibrator.rotation.z = -0.3;
    rightEquilibrator.rotation.x = -0.2;
    elevatingGroup.add(rightEquilibrator);

    // === SHIELD (protective plate) ===
    const shieldGeometry = new THREE.BoxGeometry(1.4, 0.9, 0.04);
    const shield = new THREE.Mesh(shieldGeometry, metalMid);
    shield.position.set(0, 0.35, 0.5);
    shield.rotation.x = -0.15;
    elevatingGroup.add(shield);

    // Shield cutout for barrel (just visual detail)
    const shieldNotchGeometry = new THREE.CylinderGeometry(0.18, 0.18, 0.06, 16, 1, false, 0, Math.PI);
    const shieldNotch = new THREE.Mesh(shieldNotchGeometry, metalMid);
    shieldNotch.rotation.x = Math.PI / 2;
    shieldNotch.rotation.z = Math.PI;
    shieldNotch.position.set(0, -0.05, 0.52);
    elevatingGroup.add(shieldNotch);

    // === SIGHT (aiming device) ===
    const sightBaseGeometry = new THREE.BoxGeometry(0.08, 0.12, 0.08);
    const sightBase = new THREE.Mesh(sightBaseGeometry, metalDark);
    sightBase.position.set(0.25, 0.15, 0.25);
    elevatingGroup.add(sightBase);

    const sightTubeGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.15, 12);
    const sightTube = new THREE.Mesh(sightTubeGeometry, metalDark);
    sightTube.position.set(0.25, 0.27, 0.25);
    elevatingGroup.add(sightTube);

    // === MUZZLE FLASH ===
    const muzzleFlashTexture = (() => {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      gradient.addColorStop(0, 'rgba(255, 255, 200, 1)');
      gradient.addColorStop(0.2, 'rgba(255, 200, 100, 0.9)');
      gradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.5)');
      gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    })();

    const muzzleFlash = new THREE.Sprite(
      new THREE.SpriteMaterial({
        map: muzzleFlashTexture,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0
      })
    );
    muzzleFlash.scale.set(1.2, 1.2, 1);
    muzzleFlash.position.set(0, 0.05, innerBarrelLength + 1.0);
    elevatingGroup.add(muzzleFlash);

    // === FIRING ANIMATION STATE ===
    const firingAnim = {
      active: false,
      time: 0,
      duration: 1.2,
      // Barrel recoil
      barrelRecoilDist: 1.0,
      barrelRecoilSpeed: 2,
      outerRecoilSpeed: 4,
      // Cannon rock
      cannonRecoilDist: 0.15,
      cannonRockAngle: 0.08
    };

    // Store base positions for carriage (not howitzer - spades stay fixed)
    const carriageBaseZ = carriageGroup.position.z;
    const carriageBaseRotX = carriageGroup.rotation.x;

    // ========== CANNON CONTROLS ==========
    // Track angles in degrees (rotation is offset by 180 since howitzer faces backward)
    let cannonRotationDeg = 0;  // Display value (0 = facing forward)
    let cannonElevationDeg = 40; // Initial elevation

    const rotationValueEl = document.getElementById('rotationValue');
    const elevationValueEl = document.getElementById('elevationValue');

    function updateCannonRotation() {
      // Apply rotation to turret only (upper part)
      turretGroup.rotation.y = THREE.MathUtils.degToRad(cannonRotationDeg);
      rotationValueEl.textContent = `${cannonRotationDeg}째`;
    }

    function updateCannonElevation() {
      // Clamp elevation between 0 and 80 degrees
      cannonElevationDeg = THREE.MathUtils.clamp(cannonElevationDeg, 0, 80);
      elevatingGroup.rotation.x = -THREE.MathUtils.degToRad(cannonElevationDeg);
      elevationValueEl.textContent = `${cannonElevationDeg}째`;
    }

    // Initialize displays
    updateCannonRotation();
    updateCannonElevation();

    // Button event listeners
    document.getElementById('rotLeft').addEventListener('click', () => {
      cannonRotationDeg -= 5;
      updateCannonRotation();
    });
    document.getElementById('rotRight').addEventListener('click', () => {
      cannonRotationDeg += 5;
      updateCannonRotation();
    });
    document.getElementById('elevUp').addEventListener('click', () => {
      cannonElevationDeg += 5;
      updateCannonElevation();
    });
    document.getElementById('elevDown').addEventListener('click', () => {
      cannonElevationDeg -= 5;
      updateCannonElevation();
    });

    // ========== PROJECTILE SYSTEM ==========
    const projectiles = [];
    const gravity = new THREE.Vector3(0, -9.81, 0);
    const projectileGeometry = new THREE.SphereGeometry(0.15, 16, 16);
    const projectileMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.2,
      metalness: 0.1
    });

    const velocityInput = document.getElementById('velocityInput');
    const massInput = document.getElementById('massInput');
    const recoilSpeedInput = document.getElementById('recoilSpeedInput');
    const outerRecoilSpeedInput = document.getElementById('outerRecoilSpeedInput');
    const fireBtn = document.getElementById('fireBtn');

    function fireProjectile() {
      const velocity = parseFloat(velocityInput.value) || 20;
      const mass = parseFloat(massInput.value) || 10;
      const recoilSpeed = parseFloat(recoilSpeedInput.value) || 2;
      const outerRecoilSpeed = parseFloat(outerRecoilSpeedInput.value) || 4;
      firingAnim.barrelRecoilSpeed = recoilSpeed;
      firingAnim.outerRecoilSpeed = outerRecoilSpeed;

      // Create projectile mesh
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);

      // Get muzzle world position (end of barrel)
      const muzzleLocal = new THREE.Vector3(0, 0.05, innerBarrelLength + 0.9);
      const muzzleWorld = muzzleLocal.clone();
      elevatingGroup.localToWorld(muzzleWorld);

      projectile.position.copy(muzzleWorld);
      scene.add(projectile);

      // Calculate firing direction from barrel orientation
      const direction = new THREE.Vector3(0, 0, 1);
      direction.applyQuaternion(elevatingGroup.getWorldQuaternion(new THREE.Quaternion()));
      direction.normalize();

      // Store projectile data
      projectiles.push({
        mesh: projectile,
        velocity: direction.multiplyScalar(velocity),
        mass: mass
      });

      // Trigger firing animation
      firingAnim.active = true;
      firingAnim.time = 0;
      muzzleFlash.material.opacity = 1;
    }

    fireBtn.addEventListener('click', fireProjectile);

    // Camera orientation
    const lookAtTarget = new THREE.Vector3(
      CONFIG.camera.lookAt.x,
      CONFIG.camera.lookAt.y,
      CONFIG.camera.lookAt.z
    );
    const lookDirection = new THREE.Vector3()
      .subVectors(lookAtTarget, camera.position)
      .normalize();
    let yaw = Math.atan2(lookDirection.x, lookDirection.z) + Math.PI;
    let pitch = Math.asin(THREE.MathUtils.clamp(lookDirection.y, -1, 1));

    const maxPitch = THREE.MathUtils.degToRad(CONFIG.controls.maxPitchDeg);

    function applyCameraOrientation() {
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }
    applyCameraOrientation();

    // Mouse controls
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      if (event.target.closest('#hud')) return; // Don't drag when clicking HUD
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isDragging) return;
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      yaw -= dx * CONFIG.controls.lookSensitivity;
      pitch -= dy * CONFIG.controls.lookSensitivity;
      pitch = THREE.MathUtils.clamp(pitch, -maxPitch, maxPitch);
      applyCameraOrientation();
    });

    // Keyboard controls
    const pressedKeys = new Set();
    window.addEventListener('keydown', (event) => {
      pressedKeys.add(event.code);
    });
    window.addEventListener('keyup', (event) => {
      pressedKeys.delete(event.code);
    });

    // Movement vectors
    const moveVector = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);

    // Animation loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Calculate movement
      const moveForward = (pressedKeys.has('KeyW') ? 1 : 0) - (pressedKeys.has('KeyS') ? 1 : 0);
      const moveRight = (pressedKeys.has('KeyD') ? 1 : 0) - (pressedKeys.has('KeyA') ? 1 : 0);

      if (moveForward !== 0 || moveRight !== 0) {
        // Get camera forward direction (projected onto horizontal plane)
        camera.getWorldDirection(forwardVector);
        forwardVector.y = 0;
        forwardVector.normalize();

        // Get right vector (perpendicular to forward)
        rightVector.crossVectors(forwardVector, worldUp).normalize();

        // Build movement vector
        moveVector.set(0, 0, 0);
        moveVector.addScaledVector(forwardVector, moveForward);
        moveVector.addScaledVector(rightVector, moveRight);

        if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          camera.position.addScaledVector(moveVector, CONFIG.controls.moveSpeed * dt);
        }
      }

      // Update firing animation
      if (firingAnim.active) {
        firingAnim.time += dt;
        const t = firingAnim.time;
        const duration = firingAnim.duration;

        if (t < duration) {
          // Muzzle flash - quick fade out
          const flashDuration = 0.1;
          if (t < flashDuration) {
            muzzleFlash.material.opacity = 1 - (t / flashDuration);
            muzzleFlash.scale.setScalar(1.2 + t * 3); // Expand as it fades
          } else {
            muzzleFlash.material.opacity = 0;
          }

          // Barrel recoil - fast back, slow return
          const recoilPhase = t * firingAnim.barrelRecoilSpeed;
          const barrelOffset = firingAnim.barrelRecoilDist * Math.exp(-recoilPhase * 2) * Math.sin(recoilPhase * Math.PI);
          const currentBarrelRecoil = Math.max(0, barrelOffset);
          innerBarrel.position.z = innerBarrelBaseZ - currentBarrelRecoil;
          muzzleBrake.position.z = muzzleBrakeBaseZ - currentBarrelRecoil;

          // Outer barrel secondary recoil - double speed, quarter distance
          const outerRecoilPhase = t * firingAnim.outerRecoilSpeed;
          const outerBarrelOffset = (firingAnim.barrelRecoilDist * 0.25) * Math.exp(-outerRecoilPhase * 2) * Math.sin(outerRecoilPhase * Math.PI);
          outerBarrel.position.z = outerBarrelBaseZ - Math.max(0, outerBarrelOffset);

          // Cannon body recoil and rock
          const cannonPhase = t * 8;
          const dampening = Math.exp(-t * 5);

          // Rock upward (muzzle tips up) then settle with oscillation
          const rockAngle = firingAnim.cannonRockAngle * dampening * Math.sin(cannonPhase);
          carriageGroup.rotation.x = carriageBaseRotX - rockAngle;

          // Slide back slightly
          const slideBack = firingAnim.cannonRecoilDist * dampening * (1 - Math.cos(cannonPhase * 0.5));
          carriageGroup.position.z = carriageBaseZ - slideBack;

          // Rotate wheels based on movement (backwards = negative rotation)
          const wheelRotation = slideBack / wheelRadius;
          leftWheel.rotation.x = wheelRotation;
          rightWheel.rotation.x = wheelRotation;

        } else {
          // Animation complete - reset everything
          firingAnim.active = false;
          muzzleFlash.material.opacity = 0;
          innerBarrel.position.z = innerBarrelBaseZ;
          outerBarrel.position.z = outerBarrelBaseZ;
          muzzleBrake.position.z = muzzleBrakeBaseZ;
          carriageGroup.rotation.x = carriageBaseRotX;
          carriageGroup.position.z = carriageBaseZ;
          leftWheel.rotation.x = 0;
          rightWheel.rotation.x = 0;
        }
      }

      // Update projectiles (ballistic trajectory)
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];

        // Apply gravity: v = v + g * dt
        proj.velocity.addScaledVector(gravity, dt);

        // Update position: p = p + v * dt
        proj.mesh.position.addScaledVector(proj.velocity, dt);

        // Remove if hit ground or too far away
        if (proj.mesh.position.y < 0 || proj.mesh.position.length() > 500) {
          scene.remove(proj.mesh);
          projectiles.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
