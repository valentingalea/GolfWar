<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Artillery Golf Prototype</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f14;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #hud {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 12px 14px;
      border-radius: 12px;
      background: rgba(8, 12, 18, 0.7);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e6edf5;
      font-size: 13px;
      line-height: 1.4;
      display: grid;
      gap: 10px;
      min-width: 220px;
      backdrop-filter: blur(6px);
    }
    .hud-row {
      display: grid;
      grid-template-columns: auto 1fr auto auto;
      align-items: center;
      gap: 8px;
    }
    .hud-label {
      font-weight: 600;
      color: #ffffff;
    }
    .hud-value {
      font-variant-numeric: tabular-nums;
      text-align: center;
      padding: 2px 8px;
      border-radius: 6px;
      background: rgba(255,255,255,0.08);
    }
    .hud-btn {
      padding: 4px 8px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #ffffff;
      cursor: pointer;
    }
    .hud-btn:active {
      transform: translateY(1px);
    }
    .hud-input {
      width: 100%;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      color: #ffffff;
      font-variant-numeric: tabular-nums;
    }
    canvas { display: block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div class="hud-row">
      <div class="hud-label">Gun rotation</div>
      <div id="gunRotationValue" class="hud-value">0째</div>
      <button id="gunRotationDown" class="hud-btn" type="button">&lt;</button>
      <button id="gunRotationUp" class="hud-btn" type="button">&gt;</button>
    </div>
    <div class="hud-row">
      <div class="hud-label">Gun elevation</div>
      <div id="gunElevationValue" class="hud-value">0째</div>
      <button id="gunElevationUp" class="hud-btn" type="button">^</button>
      <button id="gunElevationDown" class="hud-btn" type="button">\/</button>
    </div>
    <div class="hud-row">
      <div class="hud-label">Cannon fire</div>
      <div class="hud-value">Ready</div>
      <button id="fireBtn" class="hud-btn" type="button">Fire</button>
      <div></div>
    </div>
    <div class="hud-row">
      <div class="hud-label">Projectile velocity</div>
      <input id="projectileVelocity" class="hud-input" type="number" step="0.5" />
      <div class="hud-value">m/s</div>
      <div></div>
    </div>
    <div class="hud-row">
      <div class="hud-label">Projectile mass</div>
      <input id="projectileMass" class="hud-input" type="number" step="0.1" />
      <div class="hud-value">kg</div>
      <div></div>
    </div>
    <div class="hud-row">
      <div class="hud-label">Scale position</div>
      <div id="scalePositionValue" class="hud-value">x=0.00 y=0.00 z=0.00</div>
      <div></div>
      <div></div>
    </div>
    <div class="hud-row">
      <div class="hud-label">Cannon position</div>
      <div id="cannonPositionValue" class="hud-value">x=0.00 y=0.00 z=0.00</div>
      <div></div>
      <div></div>
    </div>
    <div class="hud-row">
      <div class="hud-label">Camera position</div>
      <div id="cameraPositionValue" class="hud-value">x=0.00 y=0.00 z=0.00</div>
      <div></div>
      <div></div>
    </div>
  </div>
  <script type="module">
    import * as THREE from 'three';

    const CONFIG = {
      camera: {
        fov: 65,
        near: 0.1,
        far: 120,
        position: { x: 0, y: 1.65, z: 8 },
        lookAt: { x: 0, y: 0, z: 0 },
        yawOffsetDeg: 180
      },
      ground: {
        size: 80,
        tileSize: 1,
        colorA: '#101724',
        colorB: '#0b111b'
      },
      scaleCylinder: {
        radius: 0.18,
        height: 1.8,
        position: { x: -3.2, y: 0.9, z: 0.6 }
      },
      cannon: {
        position: { x: 3.2, y: 0, z: 0 },
        scale: 1.5,
        rotationYDeg: 180
      },
      axis: {
        origin: { x: 0, y: 0.6, z: 0 },
        size: 0.6,
        labelOffset: 0.75,
        labelSize: 0.18
      },
      checkerTexture: {
        textureSize: 256
      },
      controls: {
        lookSensitivity: 0.0035,
        maxPitchDeg: 85,
        moveSpeed: 3.0
      },
      projectile: {
        velocity: 18,
        mass: 4.5,
        radius: 0.12
      }
    };

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 8, 45);

    const camera = new THREE.PerspectiveCamera(
      CONFIG.camera.fov,
      window.innerWidth / window.innerHeight,
      CONFIG.camera.near,
      CONFIG.camera.far
    );
    camera.position.set(
      CONFIG.camera.position.x,
      CONFIG.camera.position.y,
      CONFIG.camera.position.z
    );

    scene.add(new THREE.AmbientLight(0xffffff, 0.75));
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.1);
    keyLight.position.set(6, 8, 4);
    scene.add(keyLight);

    function createCheckerTexture() {
      const size = CONFIG.checkerTexture.textureSize;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const square = size / 2;
      ctx.fillStyle = CONFIG.ground.colorA;
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = CONFIG.ground.colorB;
      ctx.fillRect(0, 0, square, square);
      ctx.fillRect(square, square, square, square);

      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      const repeat = CONFIG.ground.size / CONFIG.ground.tileSize;
      texture.repeat.set(repeat, repeat);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return texture;
    }

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(CONFIG.ground.size, CONFIG.ground.size),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.95,
        metalness: 0.05,
        map: createCheckerTexture()
      })
    );
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    const scaleCylinder = new THREE.Mesh(
      new THREE.CylinderGeometry(
        CONFIG.scaleCylinder.radius,
        CONFIG.scaleCylinder.radius,
        CONFIG.scaleCylinder.height,
        32
      ),
      new THREE.MeshStandardMaterial({ color: 0x4ea3ff, roughness: 0.4, metalness: 0.2 })
    );
    scaleCylinder.position.set(
      CONFIG.scaleCylinder.position.x,
      CONFIG.scaleCylinder.position.y,
      CONFIG.scaleCylinder.position.z
    );
    scene.add(scaleCylinder);

    const cannon = new THREE.Group();
    cannon.position.set(
      CONFIG.cannon.position.x,
      CONFIG.cannon.position.y,
      CONFIG.cannon.position.z
    );
    cannon.rotation.y = THREE.MathUtils.degToRad(CONFIG.cannon.rotationYDeg);
    cannon.scale.set(CONFIG.cannon.scale, CONFIG.cannon.scale, CONFIG.cannon.scale);
    scene.add(cannon);

    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x2d2d2d, roughness: 0.7, metalness: 0.1 });
    const wheelGeometry = new THREE.CylinderGeometry(0.55, 0.55, 0.18, 32);
    const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
    leftWheel.rotation.z = Math.PI / 2;
    leftWheel.position.set(-0.75, 0.55, 0.25);
    const rightWheel = leftWheel.clone();
    rightWheel.position.x = 0.75;

    cannon.add(leftWheel, rightWheel);

    const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x55606b, roughness: 0.55, metalness: 0.25 });
    const base = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.5, 1.25), baseMaterial);
    base.position.set(0, 0.4, -0.125);
    cannon.add(base);

    const carriage = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.5, 0.9), baseMaterial);
    carriage.position.set(0, 0.95, 0.05);
    cannon.add(carriage);

    const barrelGroup = new THREE.Group();
    barrelGroup.position.set(0, 1.5, 0.0);
    barrelGroup.rotation.x = -THREE.MathUtils.degToRad(40);

    const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x7d8792, roughness: 0.35, metalness: 0.6 });
    const mainBarrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.18, 0.22, 1.8, 32),
      barrelMaterial
    );
    mainBarrel.rotation.x = Math.PI / 2;
    mainBarrel.position.set(0, 0, -0.45);

    const innerBarrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.12, 1.6, 32),
      barrelMaterial
    );
    innerBarrel.rotation.x = Math.PI / 2;
    innerBarrel.position.set(0, 0, 0.5);

    barrelGroup.add(mainBarrel, innerBarrel);
    cannon.add(barrelGroup);

    function createMuzzleFlashTexture() {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size / 2, size / 2, 6, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, 'rgba(255,255,210,1)');
      gradient.addColorStop(0.35, 'rgba(255,190,90,0.85)');
      gradient.addColorStop(0.7, 'rgba(255,120,40,0.4)');
      gradient.addColorStop(1, 'rgba(255,120,40,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      texture.colorSpace = THREE.SRGBColorSpace;
      return texture;
    }

    const muzzleFlash = new THREE.Mesh(
      new THREE.PlaneGeometry(0.45, 0.45),
      new THREE.MeshBasicMaterial({
        map: createMuzzleFlashTexture(),
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        opacity: 0
      })
    );
    muzzleFlash.position.set(0, 0.02, 1.45);
    muzzleFlash.visible = false;
    barrelGroup.add(muzzleFlash);

    const projectileGeometry = new THREE.SphereGeometry(CONFIG.projectile.radius, 24, 24);
    const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.35, metalness: 0.1 });
    const activeProjectiles = [];
    const gravity = new THREE.Vector3(0, -9.81, 0);

    const lookAtTarget = new THREE.Vector3(
      CONFIG.camera.lookAt.x,
      CONFIG.camera.lookAt.y,
      CONFIG.camera.lookAt.z
    );
    camera.lookAt(lookAtTarget);

    const axisOrigin = new THREE.Vector3(
      CONFIG.axis.origin.x,
      CONFIG.axis.origin.y,
      CONFIG.axis.origin.z
    );
    const axesHelper = new THREE.AxesHelper(CONFIG.axis.size);
    axesHelper.position.copy(axisOrigin);
    scene.add(axesHelper);

    function makeAxisLabel(text, color) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.font = 'bold 72px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = color;
      ctx.fillText(text, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
      return new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.axis.labelSize, CONFIG.axis.labelSize), mat);
    }

    const axisLabels = {
      x: makeAxisLabel('X', '#ff5b5b'),
      y: makeAxisLabel('Y', '#53ff74'),
      z: makeAxisLabel('Z', '#4ea3ff')
    };
    axisLabels.x.position.copy(axisOrigin).add(new THREE.Vector3(CONFIG.axis.labelOffset, 0, 0));
    axisLabels.y.position.copy(axisOrigin).add(new THREE.Vector3(0, CONFIG.axis.labelOffset, 0));
    axisLabels.z.position.copy(axisOrigin).add(new THREE.Vector3(0, 0, CONFIG.axis.labelOffset));
    scene.add(axisLabels.x, axisLabels.y, axisLabels.z);

    const ui = {
      gunRotationValue: document.getElementById('gunRotationValue'),
      gunElevationValue: document.getElementById('gunElevationValue'),
      scalePositionValue: document.getElementById('scalePositionValue'),
      cannonPositionValue: document.getElementById('cannonPositionValue'),
      cameraPositionValue: document.getElementById('cameraPositionValue'),
      gunRotationDown: document.getElementById('gunRotationDown'),
      gunRotationUp: document.getElementById('gunRotationUp'),
      gunElevationUp: document.getElementById('gunElevationUp'),
      gunElevationDown: document.getElementById('gunElevationDown'),
      fireBtn: document.getElementById('fireBtn'),
      projectileVelocity: document.getElementById('projectileVelocity'),
      projectileMass: document.getElementById('projectileMass')
    };

    ui.projectileVelocity.value = CONFIG.projectile.velocity.toFixed(1);
    ui.projectileMass.value = CONFIG.projectile.mass.toFixed(1);

    let gunRotationDeg = THREE.MathUtils.radToDeg(cannon.rotation.y);
    let gunElevationDeg = -THREE.MathUtils.radToDeg(barrelGroup.rotation.x);

    function applyGunRotation() {
      cannon.rotation.y = THREE.MathUtils.degToRad(gunRotationDeg);
      ui.gunRotationValue.textContent = `${gunRotationDeg.toFixed(0)}째`;
    }

    function applyGunElevation() {
      barrelGroup.rotation.x = -THREE.MathUtils.degToRad(gunElevationDeg);
      ui.gunElevationValue.textContent = `${gunElevationDeg.toFixed(0)}째`;
    }

    function updatePositionReadouts() {
      const scalePos = scaleCylinder.position;
      const cannonPos = cannon.position;
      const cameraPos = camera.position;
      ui.scalePositionValue.textContent = `x=${scalePos.x.toFixed(2)} y=${scalePos.y.toFixed(2)} z=${scalePos.z.toFixed(2)}`;
      ui.cannonPositionValue.textContent = `x=${cannonPos.x.toFixed(2)} y=${cannonPos.y.toFixed(2)} z=${cannonPos.z.toFixed(2)}`;
      ui.cameraPositionValue.textContent = `x=${cameraPos.x.toFixed(2)} y=${cameraPos.y.toFixed(2)} z=${cameraPos.z.toFixed(2)}`;
    }

    ui.gunRotationDown.addEventListener('click', () => {
      gunRotationDeg += 5;
      applyGunRotation();
    });
    ui.gunRotationUp.addEventListener('click', () => {
      gunRotationDeg -= 5;
      applyGunRotation();
    });
    ui.gunElevationUp.addEventListener('click', () => {
      gunElevationDeg += 5;
      applyGunElevation();
    });
    ui.gunElevationDown.addEventListener('click', () => {
      gunElevationDeg -= 5;
      applyGunElevation();
    });

    const cannonAnim = {
      active: false,
      startTime: 0,
      recoilDistance: 0.35
    };
    const baseInnerBarrelZ = innerBarrel.position.z;
    const baseCannonRockX = cannon.rotation.x;

    function spawnProjectile() {
      const velocity = Math.max(0, Number(ui.projectileVelocity.value) || 0);
      const mass = Math.max(0.1, Number(ui.projectileMass.value) || CONFIG.projectile.mass);
      const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
      projectile.castShadow = true;
      projectile.receiveShadow = true;

      const muzzlePosition = new THREE.Vector3();
      const muzzleDirection = new THREE.Vector3(0, 0, 1);
      const barrelQuaternion = new THREE.Quaternion();
      muzzleFlash.getWorldPosition(muzzlePosition);
      barrelGroup.getWorldQuaternion(barrelQuaternion);
      muzzleDirection.applyQuaternion(barrelQuaternion).normalize();

      projectile.position.copy(muzzlePosition).addScaledVector(muzzleDirection, 0.12);
      projectile.quaternion.copy(barrelQuaternion);
      scene.add(projectile);

      activeProjectiles.push({
        mesh: projectile,
        velocity: muzzleDirection.multiplyScalar(velocity),
        mass
      });
    }

    function fireCannon() {
      if (cannonAnim.active) return;
      cannonAnim.active = true;
      cannonAnim.startTime = clock.getElapsedTime();
      muzzleFlash.visible = true;
      muzzleFlash.material.opacity = 1;
      muzzleFlash.scale.set(1, 1, 1);
      spawnProjectile();
    }

    ui.fireBtn.addEventListener('click', fireCannon);

    applyGunRotation();
    applyGunElevation();
    updatePositionReadouts();

    camera.rotation.order = 'YXZ';
    const lookDirection = new THREE.Vector3()
      .subVectors(lookAtTarget, camera.position)
      .normalize();
    let yaw = Math.atan2(lookDirection.x, lookDirection.z);
    let pitch = Math.asin(THREE.MathUtils.clamp(lookDirection.y, -1, 1));
    yaw += THREE.MathUtils.degToRad(CONFIG.camera.yawOffsetDeg);
    const lookSensitivity = CONFIG.controls.lookSensitivity;
    const maxPitch = THREE.MathUtils.degToRad(CONFIG.controls.maxPitchDeg);
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    function applyCameraOrientation() {
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      if (event.target.closest('#hud')) return;
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isDragging) return;
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
      yaw -= dx * lookSensitivity;
      pitch -= dy * lookSensitivity;
      pitch = THREE.MathUtils.clamp(pitch, -maxPitch, maxPitch);
      applyCameraOrientation();
    });

    const pressedKeys = new Set();
    window.addEventListener('keydown', (event) => {
      pressedKeys.add(event.code);
    });
    window.addEventListener('keyup', (event) => {
      pressedKeys.delete(event.code);
    });

    const moveSpeed = CONFIG.controls.moveSpeed;
    const moveVector = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      const elapsed = clock.getElapsedTime();
      const moveForward = (pressedKeys.has('KeyW') ? 1 : 0) - (pressedKeys.has('KeyS') ? 1 : 0);
      const moveRight = (pressedKeys.has('KeyD') ? 1 : 0) - (pressedKeys.has('KeyA') ? 1 : 0);
      moveVector.set(0, 0, 0);
      if (moveForward !== 0 || moveRight !== 0) {
        camera.getWorldDirection(forwardVector);
        forwardVector.y = 0;
        forwardVector.normalize();
        rightVector.crossVectors(forwardVector, worldUp).normalize();
        moveVector.addScaledVector(forwardVector, moveForward);
        moveVector.addScaledVector(rightVector, moveRight);
        if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          camera.position.addScaledVector(moveVector, moveSpeed * dt);
        }
      }

      if (cannonAnim.active) {
        const t = elapsed - cannonAnim.startTime;
        const recoilDuration = 0.12;
        const settleDuration = 0.5;
        const totalDuration = recoilDuration + settleDuration;

        const recoilPhase = Math.min(Math.max(t / recoilDuration, 0), 1);
        const recoilEase = 1 - Math.pow(1 - recoilPhase, 3);
        const recoilZ = -cannonAnim.recoilDistance * recoilEase;

        let settleZ = 0;
        let rock = -0.05 * recoilEase;
        if (t > recoilDuration) {
          const settleT = (t - recoilDuration) / settleDuration;
          const damp = Math.exp(-4 * settleT);
          settleZ = cannonAnim.recoilDistance * 0.25 * damp * Math.sin(settleT * Math.PI * 3);
          rock = 0.06 * damp * Math.sin(settleT * Math.PI * 2.2);
        }

        innerBarrel.position.z = baseInnerBarrelZ + recoilZ + settleZ;
        cannon.rotation.x = baseCannonRockX + rock;

        if (t < 0.12) {
          const flashFade = 1 - t / 0.12;
          muzzleFlash.material.opacity = flashFade;
          const flashScale = 1 + (1 - flashFade) * 0.6;
          muzzleFlash.scale.set(flashScale, flashScale, flashScale);
          muzzleFlash.visible = true;
        } else {
          muzzleFlash.material.opacity = 0;
          muzzleFlash.visible = false;
        }

        if (t >= totalDuration) {
          cannonAnim.active = false;
          innerBarrel.position.z = baseInnerBarrelZ;
          cannon.rotation.x = baseCannonRockX;
          muzzleFlash.material.opacity = 0;
          muzzleFlash.visible = false;
        }
      }

      for (let i = activeProjectiles.length - 1; i >= 0; i -= 1) {
        const projectile = activeProjectiles[i];
        projectile.velocity.addScaledVector(gravity, dt);
        projectile.mesh.position.addScaledVector(projectile.velocity, dt);
        if (projectile.mesh.position.y < -2 || projectile.mesh.position.length() > 120) {
          scene.remove(projectile.mesh);
          activeProjectiles.splice(i, 1);
        }
      }

      axisLabels.x.lookAt(camera.position);
      axisLabels.y.lookAt(camera.position);
      axisLabels.z.lookAt(camera.position);
      muzzleFlash.lookAt(camera.position);
      updatePositionReadouts();
      renderer.render(scene, camera);
    }
    applyCameraOrientation();
    const clock = new THREE.Clock();
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
