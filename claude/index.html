<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>3D Scene</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0f14;
      overflow: hidden;
    }
    canvas { display: block; }
    #hud {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 12px 14px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      font-family: monospace;
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 200px;
    }
    .hud-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .hud-label {
      flex: 1;
    }
    .hud-value {
      min-width: 50px;
      text-align: center;
      background: rgba(255,255,255,0.1);
      padding: 2px 6px;
      border-radius: 4px;
    }
    .hud-btn {
      width: 28px;
      height: 28px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .hud-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    .hud-btn:active {
      background: rgba(255,255,255,0.3);
    }
    .hud-input {
      width: 60px;
      padding: 4px 6px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      color: #fff;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }
    .hud-unit {
      font-size: 11px;
      color: rgba(255,255,255,0.6);
    }
    .hud-divider {
      height: 1px;
      background: rgba(255,255,255,0.2);
      margin: 4px 0;
    }
    .hud-readonly {
      font-size: 11px;
      color: rgba(255,255,255,0.7);
      flex: 1;
      text-align: right;
    }
    .debug-section {
      /* Stage-specific debug UI sections */
    }

    /* Scoring panel - top right */
    #scoring-panel {
      position: fixed;
      right: 16px;
      top: 16px;
      padding: 12px 16px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      font-family: monospace;
      text-align: center;
      min-width: 100px;
    }
    #scoring-hole {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    #scoring-hole .hole-current {
      color: #8cf;
    }
    #scoring-shots {
      font-size: 14px;
      color: rgba(255,255,255,0.8);
    }
    #scoring-shots .shots-current {
      color: #fc8;
    }
    #scoring-shots .shots-par {
      color: rgba(255,255,255,0.5);
    }

    /* Screen fade overlay for transitions */
    #screen-fade {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000;
      opacity: 0;
      pointer-events: none;
      z-index: 9999;
      transition: opacity 0.4s ease-in-out;
    }
    #screen-fade.active {
      opacity: 1;
    }

    /* Mobile styles */
    @media (max-width: 768px), (pointer: coarse) {
      #hud {
        left: 10px;
        transform: none;
        top: 70px;
        padding: 8px 10px;
        font-size: 10px;
        min-width: auto;
        max-width: 160px;
        gap: 3px;
      }
      .hud-row {
        gap: 3px;
      }
      .hud-input {
        width: 45px;
        padding: 2px 3px;
        font-size: 10px;
      }
      .hud-btn {
        width: 22px;
        height: 22px;
        font-size: 11px;
      }
      .hud-value {
        min-width: 35px;
        font-size: 9px;
      }
      .hud-unit {
        font-size: 8px;
      }
      .hud-label {
        font-size: 9px;
      }
      /* Hide verbose debug info on mobile */
      .hud-row:has(#camPosValue),
      .hud-row:has(#camRotValue),
      .hud-row:has(#stageValue) {
        display: none;
      }
      /* Hide divider after stage row */
      .hud-row:has(#stageValue) + .hud-divider {
        display: none;
      }
      /* Mobile scoring panel */
      #scoring-panel {
        right: 10px;
        top: 10px;
        padding: 8px 12px;
        min-width: 80px;
      }
      #scoring-hole {
        font-size: 14px;
      }
      #scoring-shots {
        font-size: 11px;
      }
    }

    /* Prevent text selection and callouts on mobile */
    * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
  <!-- Screen fade overlay for transitions -->
  <div id="screen-fade"></div>

  <!-- Scoring Panel - top right -->
  <div id="scoring-panel">
    <div id="scoring-hole">Hole <span class="hole-current">1</span> / 9</div>
    <div id="scoring-shots">Shots: <span class="shots-current">0</span> <span class="shots-par">/ Par 3</span></div>
  </div>

  <div id="hud">
    <!-- Shared Debug UI (always visible) -->
    <div id="debug-shared">
      <div class="hud-row">
        <span class="hud-label">Stage</span>
        <span id="stageValue" class="hud-value" style="color: #8cf;">Idle</span>
      </div>
      <div class="hud-divider"></div>
      <div class="hud-row">
        <span class="hud-label">Cam Pos</span>
        <span id="camPosValue" class="hud-value hud-readonly">0, 0, 0</span>
      </div>
      <div class="hud-row">
        <span class="hud-label">Cam Rot</span>
        <span id="camRotValue" class="hud-value hud-readonly">0°, 0°</span>
      </div>
      <div class="hud-divider"></div>
      <div class="hud-row">
        <span class="hud-label">Ball Distance</span>
        <span id="ballDistValue" class="hud-value hud-readonly" style="min-width: 90px;">--</span>
      </div>
    </div>

    <!-- Lighting controls (conditionally shown via config) -->
    <div id="debug-lighting" style="display: none;">
      <div class="hud-divider"></div>
      <div class="hud-row">
        <span class="hud-label">Hour</span>
        <input id="hourInput" class="hud-input" type="number" value="12" min="0" max="24" step="0.5" />
        <span id="hourDisplay" class="hud-unit">12:00</span>
      </div>
      <div class="hud-row">
        <label class="hud-label" style="cursor:pointer;">
          <input type="checkbox" id="lockLighting" style="margin-right:6px;" checked />
          Lock Lighting
        </label>
      </div>
    </div>

    <!-- Stage-specific: Drone settings (Idle stage) -->
    <div id="debug-drone" class="debug-section">
      <div class="hud-divider"></div>
      <div class="hud-row">
        <span class="hud-label">Drone Height</span>
        <input id="droneHeightInput" class="hud-input" type="number" value="25" min="5" max="2000" step="5" />
        <span class="hud-unit">m</span>
      </div>
      <div class="hud-row">
        <span class="hud-label">Drone Speed</span>
        <input id="droneSpeedInput" class="hud-input" type="number" value="50" min="10" max="500" step="10" />
        <span class="hud-unit">m/s</span>
      </div>
      <div class="hud-row">
        <span class="hud-label">Transition</span>
        <input id="droneTransitionInput" class="hud-input" type="number" value="15" min="0" max="100" step="5" />
        <span class="hud-unit">m/s</span>
      </div>
    </div>

    <!-- Stage-specific: Recoil settings (Fire Cannon stage) -->
    <div id="debug-recoil" class="debug-section" style="display: none;">
      <div class="hud-divider"></div>
      <div class="hud-row">
        <span class="hud-label">Inner Recoil</span>
        <input id="recoilSpeedInput" class="hud-input" type="number" value="2" min="1" max="20" step="1" />
        <span class="hud-unit"></span>
      </div>
      <div class="hud-row">
        <span class="hud-label">Outer Recoil</span>
        <input id="outerRecoilSpeedInput" class="hud-input" type="number" value="4" min="1" max="20" step="1" />
        <span class="hud-unit"></span>
      </div>
      <div class="hud-row">
        <label class="hud-label" style="cursor:pointer;">
          <input type="checkbox" id="autoFollowShot" style="margin-right:6px;" />
          Auto-follow shot
        </label>
      </div>
      <div class="hud-row">
        <span class="hud-label">Follow Delay</span>
        <input id="autoFollowDelay" class="hud-input" type="number" min="0" max="10" step="0.5" />
        <span class="hud-unit">sec</span>
      </div>
    </div>

    <!-- Hidden inputs used by cannon.js (values synced via Game UI) -->
    <input id="velocityInput" type="hidden" value="20" />
    <input id="massInput" type="hidden" value="10" />
    <span id="rotationValue" style="display:none;">0°</span>
    <span id="elevationValue" style="display:none;">40°</span>
  </div>
  <script type="module">
    import * as THREE from 'three';

    // Import modules
    import { setupRenderer, createLighting } from './lighting.js';
    import { createSkybox, createSun, setupHourControl } from './sun.js';
    import { createHowitzer, createFiringAnimation, updateFiringAnimation, createCannonControls, createProjectileSystem } from './cannon.js';
    import { createFlag, positionFlag } from './flag.js';
    import { createDroneSystem } from './drone.js';
    import { createFirstPersonHands } from './hands.js';
    import { createMobileControls, isMobileDevice } from './mobile-controls.js';
    import { createGameState } from './game-state.js';
    import { createHandObjects, updateHandObjectAnimations, triggerButtonPress } from './hand-objects.js';
    import { createGameUI } from './game-ui.js';
    import { createTerrain, createFlatColoredTerrain } from './terrain-renderer.js';
    import * as CONFIG from './config.js';

    // ========== GAME SESSION STATE ==========
    const gameSession = {
      currentHole: 1,
      shotCount: 0,
      scores: []  // Array of { hole, shots, par }
    };

    // ========== SCORING UI ==========
    function updateScoringUI() {
      const hole = CONFIG.getHole(gameSession.currentHole);
      const totalHoles = CONFIG.COURSE.holeCount;

      // Update hole display
      const holeCurrentEl = document.querySelector('#scoring-hole .hole-current');
      const holeContainer = document.getElementById('scoring-hole');
      if (holeCurrentEl && holeContainer) {
        holeCurrentEl.textContent = gameSession.currentHole;
        holeContainer.innerHTML = `Hole <span class="hole-current">${gameSession.currentHole}</span> / ${totalHoles}`;
      }

      // Update shots display
      const shotsContainer = document.getElementById('scoring-shots');
      if (shotsContainer) {
        shotsContainer.innerHTML = `Shots: <span class="shots-current">${gameSession.shotCount}</span> <span class="shots-par">/ Par ${hole.par}</span>`;
      }
    }

    // ========== MAIN INITIALIZATION (async for terrain loading) ==========
    async function init() {

    // ========== RENDERER & SCENE ==========
    const renderer = setupRenderer();
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a2e);

    // ========== CAMERA ==========
    const camera = new THREE.PerspectiveCamera(
      CONFIG.CAMERA.fov,
      window.innerWidth / window.innerHeight,
      CONFIG.CAMERA.near,
      CONFIG.CAMERA.far
    );
    // Position camera relative to cannon (for current hole)
    const cameraStart = CONFIG.buildCameraStartPosition(gameSession.currentHole);
    camera.position.set(cameraStart.x, cameraStart.y, cameraStart.z);
    camera.rotation.order = 'YXZ';
    scene.add(camera); // Add camera to scene so attached objects render

    // ========== FIRST PERSON HANDS ==========
    const hands = createFirstPersonHands(camera);

    // ========== HAND OBJECTS ==========
    const handObjects = createHandObjects();

    // ========== GAME UI ==========
    const gameUI = createGameUI();

    // ========== LIGHTING ==========
    const lighting = createLighting(scene);

    // ========== SKYBOX ==========
    // Build sun config from WORLD settings
    const sunConfig = {
      hour: CONFIG.WORLD.sky.defaultHour,
      skyRadius: CONFIG.WORLD.sky.radius,
      sunDistance: CONFIG.WORLD.sky.sunDistance,
      sunSize: CONFIG.WORLD.sky.sunSize
    };
    const skybox = createSkybox(sunConfig);
    scene.add(skybox);

    // ========== SUN ==========
    const sun = createSun(sunConfig);
    scene.add(sun);

    // ========== HOUR CONTROL ==========
    const hourControl = setupHourControl(sun, skybox, scene, lighting, sunConfig);

    // ========== AXIS HELPER ==========
    const axisOrigin = new THREE.Vector3(
      CONFIG.WORLD.axis.origin.x,
      CONFIG.WORLD.axis.origin.y,
      CONFIG.WORLD.axis.origin.z
    );

    function createAxisLine(direction, color, length) {
      const material = new THREE.LineBasicMaterial({ color });
      const points = [
        axisOrigin.clone(),
        axisOrigin.clone().add(direction.clone().multiplyScalar(length))
      ];
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      return new THREE.Line(geometry, material);
    }

    const xAxis = createAxisLine(new THREE.Vector3(1, 0, 0), 0xff4444, CONFIG.WORLD.axis.size);
    const yAxis = createAxisLine(new THREE.Vector3(0, 1, 0), 0x44ff44, CONFIG.WORLD.axis.size);
    const zAxis = createAxisLine(new THREE.Vector3(0, 0, 1), 0x4444ff, CONFIG.WORLD.axis.size);
    scene.add(xAxis, yAxis, zAxis);

    function makeAxisLabel(text, color) {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, size, size);
      ctx.font = 'bold 80px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = color;
      ctx.fillText(text, size / 2, size / 2);

      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(CONFIG.WORLD.axis.labelSize, CONFIG.WORLD.axis.labelSize, 1);
      return sprite;
    }

    const labelX = makeAxisLabel('X', '#ff4444');
    const labelY = makeAxisLabel('Y', '#44ff44');
    const labelZ = makeAxisLabel('Z', '#4444ff');

    labelX.position.copy(axisOrigin).add(new THREE.Vector3(CONFIG.WORLD.axis.labelOffset, 0, 0));
    labelY.position.copy(axisOrigin).add(new THREE.Vector3(0, CONFIG.WORLD.axis.labelOffset, 0));
    labelZ.position.copy(axisOrigin).add(new THREE.Vector3(0, 0, CONFIG.WORLD.axis.labelOffset));

    scene.add(labelX, labelY, labelZ);

    // ========== TERRAIN ==========
    let terrain;
    if (CONFIG.TERRAIN.enabled) {
      try {
        terrain = await createTerrain({
          configFile: CONFIG.TERRAIN.configFile
        });
        console.log('Terrain with heightmap loaded');
      } catch (error) {
        console.warn('Terrain loading failed, using flat colored terrain:', error.message);
        terrain = createFlatColoredTerrain({
          size: CONFIG.TERRAIN.fallbackSize,
          resolution: CONFIG.TERRAIN.fallbackResolution
        });
      }
    } else {
      terrain = createFlatColoredTerrain({
        size: CONFIG.TERRAIN.fallbackSize,
        resolution: CONFIG.TERRAIN.fallbackResolution
      });
    }
    scene.add(terrain.mesh);

    // ========== HOWITZER ==========
    const howitzerData = createHowitzer(scene, CONFIG.buildCannonConfig(gameSession.currentHole));
    const firingAnim = createFiringAnimation();
    const cannonControls = createCannonControls(howitzerData);
    const projectileSystem = createProjectileSystem(scene, howitzerData, firingAnim);

    // ========== FLAG ==========
    const flag = createFlag(CONFIG.FLAG);
    const flagPos = CONFIG.getFlagPosition(gameSession.currentHole);
    positionFlag(flag, flagPos);
    scene.add(flag);

    // ========== CAMERA CONTROLS ==========
    let yaw = THREE.MathUtils.degToRad(CONFIG.CAMERA.initialYawDeg);
    let pitch = THREE.MathUtils.degToRad(CONFIG.CAMERA.initialPitchDeg);
    const maxPitch = THREE.MathUtils.degToRad(CONFIG.CONTROLS.maxPitchDeg);

    function applyCameraOrientation() {
      camera.rotation.y = yaw;
      camera.rotation.x = pitch;
    }
    applyCameraOrientation();

    // ========== DRONE SYSTEM ==========
    const droneSystem = createDroneSystem(camera, renderer, CONFIG.buildDroneConfig(gameSession.currentHole));
    const droneSpeedInput = document.getElementById('droneSpeedInput');
    const droneHeightInput = document.getElementById('droneHeightInput');
    const droneTransitionInput = document.getElementById('droneTransitionInput');

    // Update drone config from UI
    droneHeightInput.addEventListener('change', () => {
      droneSystem.setStartHeight(parseFloat(droneHeightInput.value) || 25);
    });

    droneSpeedInput.addEventListener('change', () => {
      droneSystem.setSpeed(parseFloat(droneSpeedInput.value) || 50);
    });

    droneTransitionInput.addEventListener('change', () => {
      droneSystem.setTransitionSpeed(parseFloat(droneTransitionInput.value) || 15);
    });

    // ========== MOBILE CONTROLS ==========
    const mobileControls = createMobileControls();

    // ========== DEBUG UI SECTIONS ==========
    const debugSections = {
      drone: document.getElementById('debug-drone'),
      recoil: document.getElementById('debug-recoil')
    };
    const stageValueEl = document.getElementById('stageValue');

    function showDebugSection(sectionName) {
      // Hide all sections
      Object.values(debugSections).forEach(el => {
        if (el) el.style.display = 'none';
      });
      // Show requested section
      if (sectionName && debugSections[sectionName]) {
        debugSections[sectionName].style.display = 'block';
      }
    }

    // ========== CANNON LOADING CONFIG ==========
    const CANNON_LOAD_DISTANCE = CONFIG.CANNON.loadDistance;

    // ========== GAME STATE MACHINE ==========
    const gameState = createGameState({
      onStageEnter: (stage) => {
        // Update stage display
        stageValueEl.textContent = stage.name;
        if (mobileControls) {
          mobileControls.setStageDisplay(stage.name);
        }

        // Update held object based on stage
        if (stage.id === 'setup-projectile') {
          // Special case: only show ball if available (not loaded, not in flight)
          if (projectileSystem.isBallAvailable()) {
            hands.setHeldObject(handObjects['sphere']);
          } else {
            hands.setHeldObject(null); // Ball is in cannon or in flight
          }
        } else if (stage.handObject) {
          hands.setHeldObject(handObjects[stage.handObject]);
        } else {
          hands.setHeldObject(null);
        }

        // Update debug UI section
        showDebugSection(stage.debugSection);

        // Handle special stages
        if (stage.id === 'drone-view') {
          const result = droneSystem.toggle(yaw, pitch);
          hands.setVisible(false);
          if (mobileControls) {
            mobileControls.setStageCyclingVisible(false);
          }
        }
      },

      onStageExit: (stage) => {
        // Hide any game UI
        gameUI.hide();

        if (stage.id === 'drone-view') {
          const result = droneSystem.toggle(yaw, pitch);
          if (result && !result.active) {
            yaw = result.yaw;
            pitch = result.pitch;
            applyCameraOrientation();
          }
          hands.setVisible(true);
          if (mobileControls) {
            mobileControls.setStageCyclingVisible(true);
          }
        }
      },

      setGameUIVisible: (panelType, visible) => {
        if (visible) {
          gameUI.show(panelType);
          // Sync cannon display values when showing cannon panel
          if (panelType === 'cannon') {
            gameUI.updateCannonDisplay(cannonControls.getRotation(), cannonControls.getElevation());
          }
        } else {
          gameUI.hide();
        }
      },

      // Try to load cannon if player is close enough
      tryLoadCannon: () => {
        // Ball not available (loaded or in flight)? Action does nothing
        if (!projectileSystem.isBallAvailable()) {
          return true; // Return true to prevent UI from showing
        }

        // Check distance to cannon
        const cannonPos = projectileSystem.getCannonPosition();
        const distance = camera.position.distanceTo(cannonPos);

        if (distance <= CANNON_LOAD_DISTANCE) {
          // Load cannon and remove ball from hand
          projectileSystem.loadCannon();
          hands.setHeldObject(null);
          return true;
        }

        return false;
      },

      fireCannon: () => {
        // Always animate button press
        triggerButtonPress(handObjects);
        // Only actually fire if loaded (fire returns false if not loaded)
        const fired = projectileSystem.fire();

        // Increment shot count and update UI on successful fire
        if (fired) {
          gameSession.shotCount++;
          updateScoringUI();
        }

        // Auto-follow: switch to drone view after successful fire (with delay)
        if (fired) {
          const autoFollowCheckbox = document.getElementById('autoFollowShot');
          if (autoFollowCheckbox && autoFollowCheckbox.checked) {
            const delayInput = document.getElementById('autoFollowDelay');
            const delaySec = parseFloat(delayInput?.value) || 2;
            setTimeout(() => {
              // Go to drone view (stage index 4), force=true to bypass keyboard restriction
              gameState.goToStage(4, true);
            }, delaySec * 1000);
          }
        }
      },

      moveToNextShot: () => {
        // Only allow if ball has stabilized
        if (!projectileSystem.isBallStabilized()) {
          return; // Ball hasn't landed yet
        }

        const ballPos = projectileSystem.getBallPosition();
        if (!ballPos) return;

        const screenFade = document.getElementById('screen-fade');
        const FADE_DURATION = 400; // ms, matches CSS transition

        // Start fade to black
        screenFade.classList.add('active');

        // After fade completes, do the move
        setTimeout(() => {
          // Get current cannon position to calculate offset
          const oldCannonPos = projectileSystem.getCannonPosition();

          // Calculate player offset from cannon
          const playerOffsetX = camera.position.x - oldCannonPos.x;
          const playerOffsetY = camera.position.y - oldCannonPos.y;
          const playerOffsetZ = camera.position.z - oldCannonPos.z;

          // Move cannon to ball position (keep Y at ground level)
          const newCannonPos = {
            x: ballPos.x,
            y: 0,
            z: ballPos.z
          };
          projectileSystem.setCannonPosition(newCannonPos);

          // Move player maintaining offset from cannon
          camera.position.set(
            newCannonPos.x + playerOffsetX,
            newCannonPos.y + playerOffsetY,
            newCannonPos.z + playerOffsetZ
          );

          // Clear projectiles (delete the ball)
          projectileSystem.clearProjectiles();

          // Reset shot count for this position (continuing same hole)
          // Note: shotCount is NOT reset - it accumulates for the hole

          // Update ball distance display
          if (ballDistValue) {
            ballDistValue.textContent = '--';
          }

          // Go back to idle stage
          gameState.goToStage(0, true);

          // Fade back in
          setTimeout(() => {
            screenFade.classList.remove('active');
          }, 100); // Small delay before fading back

        }, FADE_DURATION);
      }
    });

    // ========== BALL STABILIZATION CALLBACK ==========
    projectileSystem.onBallStabilized(() => {
      // Reset state: ball is back in hand (if in setup-projectile stage)
      const currentStage = gameState.getCurrentStage();
      if (currentStage.id === 'setup-projectile') {
        hands.setHeldObject(handObjects['sphere']);
      }
    });

    // Set initial held object (Idle stage starts with drone)
    hands.setHeldObject(handObjects['drone']);

    // Setup Game UI callbacks
    gameUI.onHide(() => {
      gameState.hideGameUI();
    });

    // Sync Game UI with cannon controls
    gameUI.setupCannonControls(
      () => cannonControls.adjustRotation(-5),
      () => cannonControls.adjustRotation(5),
      () => cannonControls.adjustElevation(5),
      () => cannonControls.adjustElevation(-5),
      () => gameUI.updateCannonDisplay(cannonControls.getRotation(), cannonControls.getElevation())
    );

    // Sync projectile values
    gameUI.syncProjectileValues(
      document.getElementById('velocityInput'),
      document.getElementById('massInput')
    );

    // ========== MOBILE CONTROLS CALLBACKS ==========
    if (mobileControls) {
      mobileControls.setOnPrevStage(() => gameState.cyclePrev());
      mobileControls.setOnNextStage(() => gameState.cycleNext());
      mobileControls.setOnAction(() => gameState.triggerAction());
    }

    // Mouse controls
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    renderer.domElement.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      if (event.target.closest('#hud')) return;
      isDragging = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (!isDragging) return;
      const dx = event.clientX - lastMouseX;
      const dy = event.clientY - lastMouseY;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;

      yaw -= dx * CONFIG.CONTROLS.lookSensitivity;
      pitch -= dy * CONFIG.CONTROLS.lookSensitivity;
      pitch = THREE.MathUtils.clamp(pitch, -maxPitch, maxPitch);
      applyCameraOrientation();
    });

    // Mouse wheel for drone speed
    window.addEventListener('wheel', (event) => {
      if (!droneSystem.isActive()) return;
      event.preventDefault();
      const delta = event.deltaY > 0 ? -10 : 10;
      const newSpeed = droneSystem.adjustSpeed(delta);
      droneSpeedInput.value = newSpeed;
    }, { passive: false });

    // Keyboard controls
    const pressedKeys = new Set();
    window.addEventListener('keydown', (event) => {
      pressedKeys.add(event.code);

      // Stage cycling
      if (event.code === 'KeyQ') {
        gameState.cyclePrev();
      }
      if (event.code === 'KeyE') {
        gameState.cycleNext();
      }

      // Direct stage access (1-6) - skip if typing in input field
      const isTypingInInput = document.activeElement && document.activeElement.tagName === 'INPUT';
      if (!isTypingInInput) {
        if (event.code === 'Digit1') gameState.goToStage(0);
        if (event.code === 'Digit2') gameState.goToStage(1);
        if (event.code === 'Digit3') gameState.goToStage(2);
        if (event.code === 'Digit4') gameState.goToStage(3);
        if (event.code === 'Digit5') gameState.goToStage(4); // Blocked by state machine
        if (event.code === 'Digit6') gameState.goToStage(5);
      }

      // Action trigger
      if (event.code === 'KeyF') {
        gameState.triggerAction();
      }
    });
    window.addEventListener('keyup', (event) => {
      pressedKeys.delete(event.code);
    });

    // Movement vectors
    const moveVector = new THREE.Vector3();
    const forwardVector = new THREE.Vector3();
    const rightVector = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);

    // HUD elements
    const camPosValue = document.getElementById('camPosValue');
    const camRotValue = document.getElementById('camRotValue');
    const ballDistValue = document.getElementById('ballDistValue');

    // Show/hide lighting controls based on config
    if (CONFIG.UI.showLightingControls) {
      document.getElementById('debug-lighting').style.display = 'block';
    }

    // Initialize auto-follow settings from config
    document.getElementById('autoFollowShot').checked = CONFIG.AUTO_FOLLOW.enabled;
    document.getElementById('autoFollowDelay').value = CONFIG.AUTO_FOLLOW.delaySec;

    // ========== ANIMATION LOOP ==========
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // Camera movement - combine keyboard and mobile inputs
      let moveForward = (pressedKeys.has('KeyW') ? 1 : 0) - (pressedKeys.has('KeyS') ? 1 : 0);
      let moveRight = (pressedKeys.has('KeyD') ? 1 : 0) - (pressedKeys.has('KeyA') ? 1 : 0);

      // Add mobile thumbstick input
      if (mobileControls) {
        // Update inertia system
        mobileControls.update(dt);

        const mobileMove = mobileControls.getMovement();
        moveForward += mobileMove.y;
        moveRight += mobileMove.x;

        // Mobile look controls (with inertia applied)
        const mobileLook = mobileControls.getLook();
        if (mobileLook.x !== 0 || mobileLook.y !== 0) {
          const mobileLookSpeed = 2.0; // radians per second at full tilt
          yaw -= mobileLook.x * mobileLookSpeed * dt;
          pitch += mobileLook.y * mobileLookSpeed * dt;
          pitch = THREE.MathUtils.clamp(pitch, -maxPitch, maxPitch);
          applyCameraOrientation();
        }
      }

      // Clamp combined input
      moveForward = THREE.MathUtils.clamp(moveForward, -1, 1);
      moveRight = THREE.MathUtils.clamp(moveRight, -1, 1);

      // Determine speed and flying mode based on drone state
      const isDroneActive = droneSystem.isActive();
      const currentSpeed = isDroneActive ? droneSystem.getSpeed() : CONFIG.CONTROLS.moveSpeed;

      if (moveForward !== 0 || moveRight !== 0) {
        camera.getWorldDirection(forwardVector);

        // In drone mode, allow full 3D flight; in FPS mode, constrain to ground
        if (!isDroneActive) {
          forwardVector.y = 0;
        }
        forwardVector.normalize();

        const tempForward = forwardVector.clone();
        tempForward.y = 0;
        tempForward.normalize();
        rightVector.crossVectors(tempForward, worldUp).normalize();

        moveVector.set(0, 0, 0);
        moveVector.addScaledVector(forwardVector, moveForward);
        moveVector.addScaledVector(rightVector, moveRight);

        if (moveVector.lengthSq() > 0) {
          moveVector.normalize();
          camera.position.addScaledVector(moveVector, currentSpeed * dt);
        }
      }

      // Update drone system
      droneSystem.update(dt, moveForward, moveRight, yaw);

      // Update firing animation
      updateFiringAnimation(firingAnim, howitzerData, dt);

      // Update projectiles
      projectileSystem.update(dt);

      // Update hand object animations
      updateHandObjectAnimations(handObjects, gameState.getCurrentStage().id, dt);

      // Update camera debug display
      camPosValue.textContent = `${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}`;
      const yawDeg = THREE.MathUtils.radToDeg(yaw).toFixed(0);
      const pitchDeg = THREE.MathUtils.radToDeg(pitch).toFixed(0);
      camRotValue.textContent = `${yawDeg}°, ${pitchDeg}°`;

      // Update ball distance display (meters and yards)
      const ballDist = projectileSystem.getBallDistance();
      if (ballDist !== null) {
        const yards = ballDist * 1.09361;
        ballDistValue.textContent = `${ballDist.toFixed(1)}m / ${yards.toFixed(1)}yd`;
      } else {
        ballDistValue.textContent = '--';
      }

      renderer.render(scene, camera);
    }

    // Initialize scoring UI
    updateScoringUI();

    animate();

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    } // end init()

    // Start the application
    init().catch(error => {
      console.error('Failed to initialize game:', error);
    });
  </script>
</body>
</html>
